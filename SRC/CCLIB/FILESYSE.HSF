\ filesys is a minimal single PAB file mechanism  BJF 17MAR2018
\ It is used only by INCLUDE to bootstrap the system.

\  *** NEEDS DISKDSR4.HSF

\ Apr 2, 2018  -re-factored for smaller size and small speed-up.
\              -better use of stack for LD/Interpret loop.

\ June 21, 2018 - REMOVED EOF to save space, MOVED to ANSFILES

\ Sept 7, 2018 filesyeE.hsf
\ - NEWFILE changed to OPENDEV
\ - OPENDEV takes 3 params now: (-- filename len card-CRU-address)
\ - added 1 CELL field after filename field to PAB
\   - holds the calulated "REALPAB" that goes into DSRNAM

\ ============================
[CC] HEX  [TC]
\ Define some LITERAL numbers in the cross-compiler to help explain things.
\ By using the cross-compiling ':' the numbers just go onto the Forth stack
\ and the cross-compiler converts them to TARGET system literals
\ This saves TARGET dictionary space for numbers used less than 4 times or so.

\ *for reference only*
\ 83E0 EQU: GPL.WKSP     \ GPL (TI O/S) workspace (CPU Registers)
\ 83F2 EQU: GPL.R9       \ address of GPL Register 9
\ 8355 EQU: LEN(DSRNAM)

TARGET-COMPILING
  8356 CONSTANT: DSRNAM     \ protected address in TI-99 O/S

\ VARIABLE: ^PAB            \ *moved to CAMEL2.HSF

\ fast fetch of pab base pointer. (*This is also the OPCODE field)
CODE: [PAB   ( -- adr) TOS PUSH,  ^PAB @@ TOS MOV,  NEXT, END-CODE

\ PAB field words calculate offset from PAB base
\ square bracket trailing to indicate they are used with [PAB
\ Example:  [PAB FBUFF] V@

CODE: FLG]    ( vaddr -- vaddr') TOS INC,         NEXT, END-CODE
CODE: FBUFF]  ( vaddr -- vaddr') TOS INCT,        NEXT, END-CODE
CODE: RECLEN] ( vaddr -- vaddr') *TOS+ *TOS+ MOV, NEXT, END-CODE \ inc. by 4 trick
CODE: CHARS]  ( vaddr -- vaddr') TOS  5 ADDI,     NEXT, END-CODE
CODE: REC#]   ( vaddr -- vaddr') TOS  6 ADDI,     NEXT, END-CODE
CODE: STAT]   ( vaddr -- vaddr') TOS  8 ADDI,     NEXT, END-CODE
CODE: FNAME]  ( vaddr -- vaddr') TOS  9 ADDI,     NEXT, END-CODE
\ dsrnam field allows for 32 bytes for fname]
CODE: DSRNAM] ( vaddr -- vaddr') TOS 20 ADDI,     NEXT, END-CODE

[CC] HEX [TC]
\ TI-99 File error Code Meaninq
\ ------------------------------
\ 0  Bad device name.
\ 1  Device is write protected.
\ 2  Bad open attribute such as incorrect file type, incorrect record length,
\    incorrect I/O mode, or no records in a relative record file.
\ 3  Illegal operation; i.e., an operation not supported on the peripheral or a
\    conflict with the OPEN attributes.
\ 4  Out of table or buffer space on the device.
\ 5  Attempt to read past the end of file. When this error occurs, the file is
\    closed. Also given for non-extant records in a relative record file.
\ 6  Device error. Covers all hard device errors such as parity and bad medium errors.
\ 7  File error such as program/data file mismatch, non-existing file opened in
\    INPUT mode, etc.

: ERR@    ( -- n)
          [PAB FLG] VC@ 5 RSHIFT ;          \ read err code from PAB & shift bits

: FILEOP  ( opcode -- err)                   \ TI99 O/S call
          [PAB VC!                           \ write opcode byte to VDP PAB
          [PAB FLG] DUP VC@ 1F AND SWAP VC!  \ clear err code bits
          0 GPLSTAT C!                       \ clear GPL status register
          DSKCARD ENABLE                     \ turn on the dsk card
          DSKLNK BLWP ERR@                   \ call DSR code, read error code
          DSKCARD DISABLE ;                  \ turn off the dsk card

\ Error handlers
: ?CARDID  ( -- ) 
           'ID C@ AA <> TS" CARD not found" ?ABORT ;

: ?DEVERR  ( link -- )
           0= IF
                DSKCARD DISABLE ( turn off the Disk card )
                CR T." * Device not found" ABORT
           THEN ;

\ generic file error handler
: ?FILERR  ( ior -- ) 
           ?DUP IF CR T." * File Err " .  ABORT THEN ;

: VPLACE   ( $addr len Vaddr -- ) \ like PLACE, but for VDP RAM
           2DUP VC! 1+ SWAP VWRITE ;

\ MAKEPAB fills in buffer address, filename, computes what I call the "realpab"
\ The realpab is the address in the PAB of the file name from the
\ location of the 1st '.' character. It is essentially a "file ID" for the TI-99 O/S.
\ The realpab VDP address is put into DRSNAM (>8356) to select the active file.
: MAKEPAB  ( addr len -- )
         [PAB DSRNAM] 2+ [PAB FBUFF] V!  \ set FBUFF 2 bytes past DSRNAM]
         2DUP [PAB FNAME] VPLACE     \ dup & write string to PAB
         /DOT NIP 1+ ( -- n)         \ compute offset upto '.' in string
         [PAB FNAME] +               \ offset + PAB_FNAME = "REALPAB"
         DUP [PAB DSRNAM] V!         \ store REALPAB to new PAB field
         DSRNAM ! ;                  \ also write to OS field

: OPENDEV ( $addr len card -- )      \ turn card on, set DSR
          ENABLE
         ?CARDID                     \ abort if card is not 'AA'
         'DSRLIST DSRFIND ( -- link)
         DUP ?DEVERR                 \ ABORT if link=0
         DUP 4 +        ( -- link $) \ link+4=DSR$ ie: Name of the DSR in CARD ROM
             C@ 8355 C! ( -- link)   \ length byte of DSRNAM -> 8355
           2+ @ 83F2 !               \ DSR code entry ADDR -> GPL.R9
;

\ ** HI LEVEL FUNCTIONS **
: FSTAT ( -- c) 9 FILEOP DROP [PAB STAT] VC@ ; \ see E/A Manual page 298 for meaning

\ primitive file words to bootstrap the system on startup
: OPN    ( addr len -- ior )
           -120 ^PAB +!                    \ get a new PAB on PAB stack
            [PAB BL 0 VFILL                \ erase the VDP PAB to be safe.
            2DUP MAKEPAB ( -- $addr len)
            14   [PAB FLG]    VC!          \ MODE: INPUT,DISPLAY,VARIABLE
            50   [PAB RECLEN] VC!          \ 80 bytes/record
 ( -- $addr len) DSKCARD OPENDEV
            0 FILEOP ;                     \ perform OPEN opcode

\ VARIABLE: LINES \ moved to CAMEL2.HSF

: ?FILE    ( n -- ) 0= TS" Filename" ?ABORT ;

CODE: 1+!  ( addr -- ) *TOS INC, TOS POP, NEXT, END-CODE

\ This word bootstraps the system on startup.
\ FILESYS8..E are nestable. Allocates a new PAB and RAM buffer
\ Usage:   TS" DSK1.START" INCLUDED
: INCLUDED  ( caddr len -- )
           DUP ?FILE
           CR T." Loading: " 2DUP TYPE
           LINES OFF
           SOURCE-ID @ >R                  \ save source-ID
           SOURCE 2>R                      \ save interpreter input source
           >IN @ >R                        \ save input string pointer
           DSRNAM @ >R                     \ save current DSR name

           OPN  ?FILERR                    \ open new file (sets new DSRNAM)
           SOURCE-ID 1+!                   \ incr. source ID (1st file is 1 etc.)

           52 DUP MALLOC >R                \ get a buffer pointer & RPUSH
          
           BEGIN
             FSTAT 3 AND 0=                \ test EOF=0, (uses low level words)
           WHILE
             2 FileOp ?FILERR              \ read record into VDP RAM, test for error
             [PAB CHARS] VC@ DUP           \ get the #chars read
             [PAB FBUFF] V@  R@ ROT VREAD  \ transfer VDP fbuff to malloc buffer
             R@  SWAP ( addr #chars)       \ this makes a stack string
             INTERPRET                     \ interpret the string
             LINES 1+!                     \ count the line
           REPEAT
           R> DROP                         \ drop buffer address from rstack
         ( 52 ) MFREE                       \ release the buffer memory

           1 FILEOP ?FILERR                \ close currently open file
           120 ^PAB +!                     \ pop back 1 pab on the pabstack
           R> DSRNAM !                     \ restore old file ID
           R> >IN !                        \ restore >IN
           2R> 'SOURCE 2!                  \ restore interpreter SOURCE
           R> SOURCE-ID !                  \ restore SOURCE-ID
           HEX ;
