 \ =========================================================================
\ T I - 9 9   C A M E L   F O R T H   P R I M I T I V E S

\ This code, compiled with a cross compiler built on HSF2012
\ a re-build of HS/Forth for DOS by Brian Fox is
\ for the TI-99 4/A Home Computer

\ Copyright (c) 2017 Brian Fox Ontario Canada
\ brian.fox@foxaudioresearch.ca
\ This program is free software; you can redistribute it and/or modify
\ it under the terms of the GNU General Public License as published by
\ the Free Software Foundation; either version 3 of the License, or
\ (at your option) any later version.
\ You should have received a copy of the GNU General Public License
\ along with this program.  If not, see <http://www.gnu.org/licenses/>.
\
\ This program is distributed in the hope that it will be useful,
\ but WITHOUT ANY WARRANTY; without even the implied warranty of
\ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
\ GNU General Public License for more details.

\ The work derived from CAMEL Forth under the GNU General Public License.
\ CamelForth (c) 2009 Bradford J. Rodriguez.
\ Commercial inquiries for Camel Forth should be directed to:
\ 115 First St., #105, Collingwood, Ontario L9Y 4W3 Canada
\ or via email to bj@camelforth.com
\ ------------------------------------------------------------------------

\ Overview:
\ This implementation creates an Indirect Threaded Code System with the
\ Top of stack (TOS) cached in Register 4 for a speed increase.
\ We have also tried to use less space where possible. Some primitives
\ are smaller in Assembly language but some are smaller in Forth.
\ We chose smaller is better except where performance would really suffer.

\ PERFORMANCE:
\ Cycle counting against Turbo Forth for TI-99, which does not keep TOS in
\ a register, shows as much as a 40% performance increase on simple primitives.
\ This is counter balanced by the slowdown of PUSHing and POPing the TOS
\ register which can slowdown other code words by as much as 100%.

\ The benchmark system, Turbo Forth, puts many small routines in the high
\ speed 16 bit RAM chip. To even come close to Turbo Forth we had to put
\ EXIT NEXT, ENTER, BRANCH and ?BRANCH and LIT in High Speed RAM.

\ CAMEL99 is roughly 8% faster than Turbo Forth in simple math benchmarks
\ but is slower in number conversion and screen display.

\ Macros have been created to code the Forth Virtual Machine in a CPU
\ independant manner. They make sense to a Forth programmer but may
\ be less clear to someone new to Forth.
\ (see FORTHVM.HSF for detailS)

\ Multi-tasking ready:
\ CAMEL99 commandeers R13,R14 & R15 to allow the smallest multi-tasker
\ ever made. 3 instructions lets us jump to a task in about 20uS.
\ see: TASKS99.HSF

\ CREDITS:
\         Special thanks Mark Wills for giving the world TurboForth
\         It provided examples of how to deal with the crazy TI-99/4a

\         Also thanks goto to Lee Stewart atariage.com who can spot
\         a bug a nautical mile away.

\         Big thanks to Dr. Brad Rodriguez for Camel Forth MSP430
\         The MSP430 provides other code examples that sometimes
\         translate nicely to the TMS9900

\ =========================================================================
\ C A M E L 9 9   R E G I S T E R   N A M E S   A N D  U S A G E

\ R0      general purpose register
\ R1      general purpose register
\ R2      general purpose register
\ R3      general purpose register
\ R4      TOP of stack cache
\ R5      Temp for NEXT, overflow for '*' and '/',  general purpose register
\ R6      parameter stack pointer
\ R7      return stack pointer
\ R8      Forth 'W' register OR general purpose in a system CODE word
\ R9      Forth VM Instruction pointer
\ R10     Forth's "NEXT" routine cache
\ R11     9900 sub-routine return register  - OR - general purpose register
\ R12     9900 CRU register                 - OR - general purpose register
\ R13     Multi-tasker LINK to next task
\ R14     Multi-tasker Program counter: holds address of TSTAT routine see: TASKS99.HSF
\ R15     Multi-tasker task Status register

  [UNDEFINED] XASSEMBLER
  [IF]   include cc9900\asm99003.hsf
  [ELSE] CR .( ** 9900 XASSEMBLER is loaded **)
  [THEN]

\ ==========================================================================
\ F O R T H   V I R T U A L   M A C H I N E  S U P P O R T

CROSS-COMPILING
[UNDEFINED] CALL,
[IF]
    CR ." Defining Forth Virtual machine MACROs ..."
    include cc9900\forthvm.hsf           \ contains macros: PUSH POP CALL etc...
[THEN]


\ ==========================================================================
\ T I - 9 9   S U P P O R T

    cr ." Including TI99 EQUATES"
    include cc9900\99equ.hsf


\ ==========================================================================
\ Compiler extensions to manage copying certain primitives into hi-speed (HS) RAM

loadaddress 2 cells + equ HSprims                   \ beginning of the code to be copied to HS ram
                 8388 equ HSstart                   \ where we copy the code to in HS ram

: >HSRAM  ( label -- addr') HSprims -  HSstart + ;  \ converts assembler label to HS RAM address
: CFA!    ( addr -- )   -2 TALLOT  DATA,  ;         \ move dictionary pointer back 1 cell, patch 'addr' into CFA field

\ ==========================================================================
\ XASM99 TI-99 CROSS-ASSEMBLER DIRECTIVES
cr ." Assembling Forth Primitives"

CROSS-ASSEMBLING
              START.                        \ sets a timer
              NEW.                          \ init target memory segment to FFFF
              ABSOLUTE A000 ORIGIN.         \ we must set the origin before TI-99.EA5 directive
              TI-99.EA5                     \ format the memory/file header for TI-99 EA5 file format

\ ==========================================================================
\ FAST CODE PRIMITIVES. Concept from TI-Forth and TURBO Forth, by Mark Wills

\ The following code is copied into TI-99 "PAD" memory chip by INIT to address _HSstart (8388)
\ TI-99 "PAD" is the ONLY zero wait-state 16 bit buss wide memory chip in the TI-99.
\ But there is only 256 bytes! (shame)
\ Having these critical routines in fast memory makes more difference than ANY other improvements

l: _exit      IP RPOP,        \ placing EXIT before next saves space and is faster  22+next=74 vs 84 in TF
l: _next                      \ Forth ITC NEXT routine
@@9:         *IP+ W MOV,      \ move CFA into Working register & incr IP        \ 22
l: _exec     *W+  R5 MOV,     \ move contents of CFA to R5 & INCR W             \ 22
             *R5  B,          \ branch to the address in R5                     \ 12
                                                                              \ = 56
l: _?branch   \ Faster way to avoid penalty of TOS refill
              TOS DEC,        \ After DEC if tos=0, this will cause a carry flag                                  10
              TOS POP,        \ refill TOS changes L> A> EQ flags, BUT does not change carry flag       22
              @@2 JOC,        \                                                                         10
l: _branch   *IP IP ADD,      \ *IP points to an offset number in memory. Add it to IP causes a jump.
              @@9 JMP,        \ *replaced NEXT, with short JMP. 20% faster! same size                   10
@@2:          IP INCT,        \ move IP forward past branch offset (don't branch)                       10
              @@9 JMP,        \ JMP to _next

l: _enter
              IP RPUSH,       \ push IP register onto the return stack            28
              W IP MOV,       \ move PFA into Forth IP register                   14
              @@9 JMP,        \                                                =  42

l: _lit       TOS     PUSH,   \ 28
             *IP+ TOS MOV,    \ 22
              @@9 JMP,

l: _@        *TOS TOS MOV,
              @@9 JMP,


l: _HSend                     \ this label tells the compiler where the high speed code ends.



\ ==========================================================================
\ calculate and name the entry points for the fast memory code

\ * Address NEXT2 must be loaded into R10 at startup *  ( see INIT in CAMEL99.HSF)
\ --------------------------------------------------
 _exit  >HSRAM equ EXIT2
 _next  >HSRAM equ NEXT2       \ entry address of NEXT in fast RAM
 _enter >HSRAM equ ENTR        \ code address of enter. This resolves 'DOCOL in CAMEL99.HSF
  _HSend >HSRAM equ HSend      \ end of hi-speed memory code. Needed by copy loop in INIT

\ ==========================================================================
\ COMPILER CONTROL

FALSE VALUE REGISTERS  \ TRUE -> use registers for do loop

\ ==========================================================================
CR .( F O R T H  P R I M I T I V E S  B E G I N)

\ The following words have been called "DOERS" by many in the past. I don't like the name.
\ I have chosen to to call them "EXECUTORS".  The words are the EXECUTION CODE that runs
\ for the various type of words in a Forth sytstem.

CODE: EXIT    ( -- )
              EXIT2 CFA!               \ convert label address to fast RAM address store in CFA
              END-CODE


CODE: DOCOL   ( a -- )                 \ Executor that executes a "colon" definition.
              ENTR CFA!
              END-CODE

CODE: LIT     ( -- w )                 \ Execute a LITERAL number in the Forth program
             _LIT >HSRAM CFA!
\              TOS PUSH,       \ 28
\             *IP+ TOS MOV,    \ 22
\              NEXT,
              END-CODE

\ CODE: DLIT
\              TOS PUSH,               \ save the TOS register
\             *IP+ TOS MOV,
\              IP++                    \ move IP to next program cell
\             *IP PUSH,                \ move next XT onto 2nd stack item
\              IP++                    \ move IP to next program cell
\              NEXT,
\              END-CODE

CODE: DOCON   ( -- n )                 \ Executor that executes a "CONSTANT"
              TOS PUSH,                \ make room in TOS
             *W TOS MOV,               \ put contents of PFA (W+2) in TOS
              NEXT,
              END-CODE

CODE: DOVAR   ( -- addr)               \ Executor that executes a "VARIABLE"
              NOP,    \ ??? when I remove this do-user breaks ???
              TOS PUSH,                \ <-- dovar  enters at this address
              W   TOS MOV,             \ put the parameter field address into TOS
              NEXT,
              END-CODE

\ In CAMEL99 the 9900 WP register doubles as USER pointer
CODE: DOUSER ( -- addr)
              TOS PUSH,                \ Executor that executes a "USER VARIABLE" (local to each task)
              TOS STWP,                \ store workspace register WP in TOS
             *W TOS ADD,               \ add the offset stored in the USER variable's parameter field
              NEXT,
              END-CODE

\ ==================================================
\ DODOES is the code action of a DOES> clause.
\ For ITC Forth:
\ defined word:  CFA: doescode
\                PFA: parameter field
\
\ Note: in the TMS9900 implementation we use B @DODOES. (branch to address)
\ DODOES is entered with W=PFA (parameter field address)
\ DODOES moves  W to the TOP of Stack (TOS)
\ So the high-level Forth code begins with the address of the parameter
\ field on top of stack. ( cached in R4 in this version)
\
\ MSP430 version translates to TMS9900 very easily
CODE: DODOES  ( -- a-addr)
              TOS PUSH,       \ save TOS reg on pstack (uses PUSH macro)
              W TOS MOV,      \ put defined word's PFA in TOS
              IP RPUSH,       \ push old IP onto return stack
             -2 (W) IP MOV,   \ PFA-2=CFA: CFA@ -> IP
              IP 4 ADDI,      \ move Forth IP past "BL @DODOES" code
              NEXT,
              END-CODE

CODE: EXECUTE ( xt -- )
              TOS W MOV,      \ move the execution token in TOS into temp
              TOS POP,        \ refill TOS
             *W+ R5 MOV,      \ move contents of the XT (the address of the doer routine) to R5
             *R5 B,           \ branch to the address of the DOER routine
              END-CODE

CODE: ?BRANCH
             _?BRANCH >HSRAM CFA!      \ put fast address into the CFA
              END-CODE

CODE: BRANCH
             _BRANCH >HSRAM CFA!       \ put fast address into the CFA
              END-CODE

\ ==========================================================================
CR .( M E M O R Y  F E T C H  &  S T O R E)

CODE: !      ( n addr -- )
             *SP+ *TOS MOV,         \ 20
              TOS POP,              \ 22
              NEXT,                 \ 42 vs 48 in Turbo Forth
              END-CODE

CODE: @      ( a -- w )
             _@ >HSRAM CFA!
\             *TOS TOS MOV,           \ 18 vs 48 in Turbo Forth
\              NEXT,
              END-CODE

CODE: 2!     ( d addr -- ) \ the top of stack is stored at the lower adrs
             *SP+ 2 (TOS) MOV,
             *SP+ *TOS  MOV,
              TOS POP,
              NEXT,
              END-CODE

CODE: 2@     ( addr -- d) \ the lower address will appear on top of stack
             *TOS+  PUSH,            \ 18 fetch from addr to TOS register
             *TOS   TOS MOV,         \ 28
              NEXT,                 \ =46
              END-CODE

CODE: C!     ( c addr -- )
             *SP SWPB,               \ 14
             *SP *TOS MOVB,          \ 22   can't auto incr. It will only be by 1 with MOVB
              SP INCT,               \ 10   inc. stack pointer by 2
              TOS POP,               \ 22
              NEXT,                 \ =68
              END-CODE

CODE: COUNT  ( addr -- addr' u)
              TOS PUSH,              \ make a copy of addr
             *SP INC,                \ inc. past the count byte
l: _C@       *TOS TOS MOVB,          \ put C@ inline to save space
              TOS 8 SRL,
              NEXT,
              END-CODE

CODE: C@      _C@  CFA! END-CODE     \ give _C@ a dictionary header

CODE: +!     ( n addr --)
             *SP+ *TOS ADD,          \ 14+8+4 = 26 cycles
              TOS POP,               \          22 cycles
              NEXT,                  \ -------------------
              END-CODE               \          48 cycles

CODE: C+!     ( c addr -- ) \ 8 bytes versus 12 bytes in Forth
             *SP SWPB,               \ 14
             *SP *TOS ADDB,          \ 22
              SP INCT,               \ 10
              TOS POP,               \ 22
              NEXT,                 \ =68
              END-CODE

\ ==========================================================================
CR .( R E T U R N   S T A C K)

CODE: RP@     ( -- a )
              TOS PUSH,
              RP TOS MOV,
              NEXT,
              END-CODE

CODE: RP!     ( a -- )
              TOS RP MOV,
              TOS POP,
              NEXT,
              END-CODE

CODE: >R      ( w -- )
              TOS RPUSH,            \ 28
              TOS POP,              \ 22
              NEXT,
              END-CODE              \ 50 vs 36 in TurboForth

CODE: R>      ( -- w )
              TOS PUSH,             \ 28
              TOS RPOP,             \ 22
              NEXT,
              END-CODE              \ 50 vs 36 in TurboForth

CODE: R@      ( -- w )
              TOS PUSH,
             *RP TOS MOV,
              NEXT,
              END-CODE

-1 [IF]    \ these are bigger in ASM but faster
CODE: 2>R    ( d -- ) ( r-- n n)
              RP -4 ADDI,          \ 14
              TOS 2 (RP) MOV,      \ 22
             *SP+   *RP MOV,       \ 26
              TOS POP,             \ 22
              NEXT,              \ = 84
              END-CODE

CODE: 2R>     ( -- d )
              TOS PUSH,             \ 28
              SP DECT,              \ 10
             *SP  RPOP,             \ 26
              TOS RPOP,             \ 22
              NEXT,               \ = 88
              END-CODE

CODE: 2R@     ( -- d )           \ fixed June 18 2019 V2.0.17
              TOS PUSH,
             *RP PUSH,
             2 (RP) TOS MOV,
              NEXT,               \ = 80
              END-CODE
[THEN]

\ ===================================================================
CR .( D A T A   S T A C K)

CODE: SP@     ( -- a )
              TOS PUSH,
              SP TOS MOV,
              NEXT,
              END-CODE

CODE: SP!     ( a -- )
              TOS SP MOV,
              TOS POP,
              NEXT,
              END-CODE

CODE: DROP    ( w -- )
              TOS POP,               \ 22 *SP+ TOS MOV,
              NEXT,
              END-CODE

CODE: NIP     ( n n' -- n')          \ 10
              SP++
              NEXT,
              END-CODE

CODE: ?DUP    ( x -- 0 | x x)       \ ?DUP interleaved with DUP to save space
              TOS TOS MOV,          \ test for TOS<>0
              @@1 JNE,              \ if TOS<>0 goto DUP
              NEXT,
              END-CODE
+CODE: DUP    ( w -- w w )          \ create a Forth Header for DUP
@@1:          TOS PUSH,
              NEXT,
              END-CODE

CODE: SWAP    ( w1 w2 -- w2 w1 )
              TOS   W MOV,          \ 14
             *SP  TOS MOV,          \ 18
              W   *SP MOV,          \ 18
              NEXT,                 \ 50
              END-CODE

CODE: OVER   ( w1 w2 -- w1 w2 w1 )
\             _OVER >HSRAM CFA!
              TOS PUSH,             \ 28
              2 (SP) TOS MOV,       \ 22
              NEXT,                 \ 50
              END-CODE

CODE: ROT    ( n1 n2 n3 --  n2 n3 n1)
              2 (SP)    W MOV,      \ move bottom n1 to TEMP             14+8 =   22
             *SP   2 (SP) MOV,      \ move n2 to bottom position         14+4+8 = 26
              TOS     *SP MOV,      \ n3 moves to second                 14+4   = 18
              W       TOS MOV,      \ n1 goes to top of stack register   14+0   = 14
              NEXT,                 \                                             80
              END-CODE

CODE: -ROT    ( n1 n2 n3 --  n2 n3 n1)
              TOS       W MOV,
             *SP      TOS MOV,
              2 (SP)  *SP MOV,
              W    2 (SP) MOV,
              NEXT,
              END-CODE

\ byte/word conversions
CODE: ><      ( n -- n )            \ swap bytes in n
              TOS SWPB,             \ handy and only 1 instruction
              NEXT,
              END-CODE

\ these are very handy FUSE & SPLIT
CODE: SPLIT  ( AABB --  BB AA )     \ used in \LIB\SOUND.FTH
              TOS W MOV,            \ make a copy
              TOS 8 SRL,            \ slide 'AA' to the right
              W 00FF ANDI,          \ mask out AA from the copy
              W PUSH,
              NEXT,
              END-CODE

CODE: FUSE   ( BB  AA -- AABB ) \ FUSE 2 bytes into a 16 bit word
              TOS SWPB,
             *SP+ TOS SOC,         \ same size as Forth, 3X faster
              NEXT,
              END-CODE

\ used in number conversion. Same size as DROP DROP 3X faster
CODE: 2DROP   ( n n -- )
              SP INCT,           \ 10
              TOS POP,           \ 28
              NEXT,            \ = 38  vs  110 in Forth
              END-CODE

\ used 10x in the CAMEL Forth Kernel. Provides good speedup on some critical words
CODE: 2DUP   ( n1 n2 -- n1 n2 n1 n2 )
             *SP W MOV,            \ 18 copy n1
              TOS PUSH,            \ 28 copy n2 onto stack     SP DECT,   TOS *SP MOV,
              W PUSH,              \ 28 push onto task         SP DECT,   W   *SP MOV,
              NEXT,                \
              END-CODE             \ 74,  3 instructions, 6 bytes

CODE: 2SWAP   ( n1 n2 n3 n4-- n3 n4 n1 n2)
              TOS       R0 MOV,    \ n4  14
             *SP        R1 MOV,    \ n3  14
              2 (SP)   TOS MOV,    \ n2  22
              4 (SP)   *SP MOV,    \ n1  26
              R0    2 (SP) MOV,    \     22
              R1    4 (SP) MOV,    \     22
              NEXT,                \    120
              END-CODE

\ CODE: 2OVER  ( d1 d2 -- d1 d2 d1)  \ this is smaller in Forth
\             *SP W MOV,             \ d2 lsb -> temp                             18
\              W   PUSH,             \ push temp                                  28
\              TOS PUSH,             \ push d2 MSBits                             28
\              4 (SP) TOS MOV,       \ pick 4th item, d1 MSBits to TOS            22
\              6 (SP) *SP MOV,       \ pick 6th item, d1 LSBits to next on stack  26
\              NEXT,                 \ 18 bytes                                  122
\              END-CODE

CODE: PICK   ( n -- n)   \ GForth ITC takes 10 intel instructions for PICK
              TOS W MOV,   \ 14
              W 1 SLA,     \ 16
              SP W ADD,    \ 14
             *W TOS MOV,   \ 18
              NEXT,       \  62
              END-CODE

\ ===================================================================
CR .( L O G I C A L   O P E R A T I O N S)

CODE: AND     ( w w -- w )
             *SP INV,                  \ thanks to Mark Wills!   14      22
             *SP+ TOS SZC,             \ RFM for TMS9900 BF      20      25
              NEXT,                                           \ =34  vs  47
              END-CODE

CODE: OR      ( w w -- w )
             *SP+ TOS OR,                                     \  22  vs  26
              NEXT,
              END-CODE

CODE: XOR     ( w w -- w )
             *SP+ TOS XOR,
              NEXT,
              END-CODE

\ ===================================================================
CR .( A R I T H M E T I C)
\ TOS in place math is about 40% faster with TOS in register
CODE: 1+     ( n -- n')     \ changed from 1+ for compliance
              TOS INC,
              NEXT,
              END-CODE

CODE: 1-      ( n -- n')
              TOS DEC,
              NEXT,
              END-CODE

CODE: 2+     ( n -- n)   \ changed from 2+ for compliance
              TOS INCT,
              NEXT,
              END-CODE

CODE: 2-     ( n -- n)
              TOS DECT,
              NEXT,
              END-CODE

CODE: 2*      ( n -- n)     \ changed from 2* for compliance
              TOS TOS ADD,  \ mpy instruction is 52 clocks minimum. This is 14 clocks
              NEXT,
              END-CODE

CODE: 4*      ( n -- nx4)    \ use in graphics & sprite calulations
              TOS 2 SLA,
              NEXT,
              END-CODE

CODE: 8*      ( n -- nx8)   \ use in graphics & sprite calulations
              TOS 3 SLA,
              NEXT,
              END-CODE

CODE: 2/      ( n -- n)     \ div instruction is 52 clocks minimum
              TOS 1 SRA,    \ this is 14
              NEXT,
              END-CODE

\ ===================================================================
CR .( ANS Shift operations)

CODE: RSHIFT  ( n bits -- n')
              TOS R0  MOV,            \ 14 the shift bits MUST be in R0 to do this
             *SP+ TOS   MOV,          \ 22
              R0 R0 MOV,              \ ANS:  1 0 LSHIFT -> 1
              NE IF,                  \       so skip the shift if R0=1
                 TOS R0 SRL,
              ENDIF,
              NEXT,
              END-CODE

CODE: LSHIFT  ( n bits -- n')
              TOS R0  MOV,           \ the shift bits MUST be in R0 to do this
             *SP+ TOS MOV,
              R0 R0 MOV,
              NE IF,
                 TOS R0  SLA,
              ENDIF,
              NEXT,
              END-CODE

\ CODE: SRC     ( n bits -- n')     \ non ANS Forth. Circular shift. Nice!
\              TOS R0 MOV,
\             *SP+ TOS MOV,
\              TOS R0 SRC,
\              NEXT,
\             END-CODE

CODE: INVERT  ( u -- w)
              TOS INV,              \ 10  vs  14 in stack memory
              NEXT,
              END-CODE

\ : +   ( u1 u2 -- u ) UM+ DROP ;  original Camel Forth code is bigger
CODE: +       ( u1 u2 -- u )
             *SP+ TOS ADD,         \ ADD 2nd item to TOS and incr stack pointer.
              NEXT,
              END-CODE

\ I found the 9900 weirdness but Brad's MSP430 code is 1 more instruction than mine :-)
CODE: -       ( u1 u2 -- u )
             *SP+ TOS SUB,
              TOS NEG,         \ sign is wrong when subtracting a register from memory
              NEXT,
              END-CODE

CODE: M+      ( d n -- d )     \ add single to double signed output
              TOS  2 (SP) ADD,
              OC IF,
                 *SP INC,
              ENDIF,
             *SP+ TOS MOV,
              NEXT,
              END-CODE

CODE: ABS      ( n -- n )
              TOS ABS,
              NEXT,
              END-CODE

CODE: NEGATE ( n -- n )
              TOS NEG,
              NEXT,
              END-CODE

CODE: ALIGNED ( n -- n)
              TOS INC,
              TOS -2 ANDI,
              NEXT,
              END-CODE

\ ===================================================================
CR .( M U L T I P L Y   A N D   D I V I D E)

CODE: UM*     ( n n -- d)     \ 2 cells in -- 2 cells out
             *SP  TOS MPY,    \ 52+4=56
              R5  *SP MOV,    \ 18
              NEXT,           \ 74 vs 132 in TF
              END-CODE

CODE: *      ( n n -- n)      \ same size as  : *  UM* DROP ; but faster
             *SP+ R3 MOV,     \ 22
              TOS R3 MPY,     \ 52  cool trick !
              NEXT,           \ 74
              END-CODE

CODE: UM/MOD ( ud u1 -- u2 u3 ) \ numerator(32bits), divisor -- remainder,quotient
             *SP+ R1 MOV,     \ POP the high word of ud to r1                 22
             *SP  R2 MOV,     \ move low word of ud to r2 (keep stack pos.)   18
              TOS R1 DIV,     \ perform unsigned division                    124
              R1 TOS MOV,     \ quotient to tos                               14
              R2 *SP MOV,     \ push remainder                                18
              NEXT,           \                                              210
              END-CODE

\ ===================================================================
\ array operation nice in theory, but not that important
0 [IF]
CODE: *+     ( addr ndx size -- addr')  \ array address calculator
             *SP+ TOS MPY,              \ 60
             *SP+ TOS MOV,              \ 22
              R5  TOS ADD,              \ 14
              NEXT,                    \ =96
              END-CODE
[THEN]

\ ===================================================================
cr .( C O M P A R I S O N)

CODE: 0=     ( n -- ?)
              TOS TOS MOV,
              @@9 JEQ,
@@8:          TOS CLR,
              NEXT,
@@9:          TOS SETO,
              NEXT,

\ using +CODE allows all these routines to jump inside CODE: .. END-CODE
+CODE: =      ( n n -- ? )
             *SP+ TOS CMP,
              @@9 JEQ,
              @@8 JMP,

+CODE: 0<     ( n -- flag )
              TOS TOS  MOV,
              @@9 JLT,
              @@8 JMP,

+CODE: U<    ( n1 n2 -- flag)
             *SP+ TOS CMP,
              @@9 JL,
              @@8 JHE,             \ changed to JHE due to bug on U>

+CODE: >     ( n1 n2 -- flag)
             *SP+ TOS CMP,
              @@9 JGT,
              @@8 JMP,

+CODE: <     ( n1 n2 -- flag)
             *SP+ TOS CMP,
              @@9 JLT,
              @@8 JMP,

-1 [IF]   \ saves 14 bytes if Forth versions are used

+CODE: U>    ( n1 n2 -- flag)
             *SP+ TOS CMP,
              @@9 JH,
              @@8 JLE,             \ *BUG* had to use JLE not JL
+CODE: 0>     ( n -- flag )
              TOS TOS MOV,
              @@9 JGT,
              @@8 JMP,
+CODE: <>    ( n n -- ? )
             *SP+ TOS CMP,
              @@9 JNE,
              @@8 JMP,
[THEN]              
              END-CODE


\ ===================================================================
CR .( MIN & MAX )
CODE: MIN     ( n1 n2 -- n)
             *SP TOS CMP,    \ compare n1 & n2
              @@1 JLT,       \ if n1 < n2 goto @@1:
              SP INCT,       \ otherwise NIP n1
              NEXT,
+CODE: MAX   ( n1 n2 -- n)
             *SP  TOS CMP,   \ compare n1 & n2
              @@2 JGT,       \ if n1 > n2 goto @@1:
              SP INCT,       \ otherwise DROP n1
              NEXT,
@@1: @@2:     TOS POP,       \ pop n1 into TOS
              NEXT,
END-CODE   \ for MIN

\ ===================================================================
CR .(  M O V E   C M O V E  C M O V E >   F I L L )

CODE: CMOVE  ( src dst n -- )  \ forward character move
             *SP+ R0 MOV,       \ pop DEST into R0                         22
             *SP+ R1 MOV,       \ pop source into R1                       22
              TOS TOS MOV,
              NE IF,            \ if n<>0 do move
                 BEGIN,
                  *R1+ *R0+ MOVB, \ byte move, with auto increment by 1.   26
                   TOS DEC,       \ n is in TOS (R4)                       10
                 EQ UNTIL,
              ENDIF,                                                  \    10
              TOS POP,                                                \    22
              NEXT,                                                   \   112
              END-CODE

CODE: CMOVE>  ( src dst n -- )  \ move chars from end of string and go backwards
             *SP+ R0 MOV,       \ pop DEST into R0
             *SP+ R1 MOV,       \ pop source into R1
              TOS TOS MOV,
              NE IF,            \ if n<>0 do move
                 TOS R0 ADD,    \ point to end of src
                 TOS R1 ADD,    \ point to end of dest
                 BEGIN,
                   *R1 *R0 MOVB,
                    R1 DEC,     \ move the pointers back (NO auto decrement, damn)
                    R0 DEC,
                    TOS DEC,    \ decr the counter in TOS (R5)
                 EQ UNTIL,
              ENDIF,
              TOS POP,
              NEXT,
              END-CODE

CODE: FILL   ( addr cnt char -- )
             *SP+ R0 MOV,       \ pop cnt->R0                   22
             *SP+ R1 MOV,       \ pop addr->R1                  22
              TOS SWPB,         \                               10
              BEGIN,
                TOS *R1+ MOVB,  \ char is in TOS                20
                R0 DEC,         \ decr. count                   10
              EQ UNTIL,         \ loop until r0=0               10
              TOS POP,          \ refill the TOS register       22
              NEXT,             \                             =116
              END-CODE

\ ===================================================================
cr .( ANS Forth DO/LOOP )

\  D O   L O O P S

\ Adapted from CAMEL Forth MSP430
\ ; '83 and ANSI standard loops terminate when the boundary of
\ ; limit-1 and limit is crossed, in either direction.  This can
\ ; be conveniently implemented by making the limit 8000h, so that
\ ; arithmetic overflow logic can detect crossing.  I learned this
\ ; trick from Laxen & Perry F83.

\ ====================================================================
REGISTERS [IF]
\ CAMEL Forth prefers to put loop index and limit in registers.
\ Using 2 registers makes DO LOOPs about 14% faster
\ BUT it is NOT COMPATIBLE with the workspace based multi-tasker

  INCLUDE CC9900\CCLIB\DOFAST.HSF
CR .( *** NOT MULTI-TASKER COMPATIBLE!! ***)

[ELSE]

\ ===================================================
\ conventional do loops use 2 cells on the RSTACK
cr .( Rstack based DO/LOOP )

CODE: <?DO> ( limit ndx -- )
             *SP TOS CMP,       \ compare 2 #s
              @@1 JNE,          \ if they are not the same jump to regular 'do.' (BELOW)
              SP INCT,          \ remove limit
              TOS POP,          \ refill TOS
              EXIT2 @@ B,       \ otherwise do a forth 'exit'

+CODE: <DO> ( limit indx -- )
@@1:          R0  8000 LI,      \ load "fudge factor" to LIMIT
             *SP+ R0  SUB,      \ Pop limit, compute 8000h-limit "fudge factor"
              R0  TOS ADD,      \ loop ctr = index+fudge
              R0  RPUSH,        \ rpush limit
              TOS RPUSH,        \ rpush index
              TOS POP,          \ refill TOS
              NEXT,
              END-CODE

CODE: <LOOP>
             *RP INC,           \ increment loop
@@2:          @@1 JNO,          \ if no overflow then loop again
              IP INCT,          \ move past (LOOP)'s in-line parameter
              @@3 JMP,          \ JUMP to unloop
@@1:         *IP IP ADD,        \ jump back  (NO SPEED UP BY BRANCHING TO hi-speed version)
              NEXT,            \ branch *R10 next is slower
\             *IP+ W  MOV,       \ INLINE NEXT: loop IS 4% faster
\             *W+  R5 MOV,
\             *R5  B,

+CODE: <+LOOP>
              TOS *RP ADD,      \ saving space by jumping into <loop>
              TOS POP,          \ refill TOS, (does not change overflow flag)
              @@2 JMP,
+CODE: UNLOOP
@@3:          RP 4 ADDI,        \ collapse rstack frame (3 cells)
              NEXT,
              END-CODE

CODE: I       ( -- n)
              TOS PUSH,         \ making space in TOS slows this down  28
             *RP TOS MOV,                                          \   18
              2 (RP) TOS SUB,   \ index = loopindex - fudge            22
              NEXT,                                                \   68
              END-CODE

CODE: J       ( -- n)
              TOS PUSH,
              4 (RP) TOS MOV,   \ outer loop index is on the rstack
              6 (RP) TOS SUB,   \ index = loopindex - fudge
              NEXT,
              END-CODE
[THEN]

CODE: BOUNDS ( adr len -- adr2 adr1)  \ same size as Forth version
             *SP R1 MOV,
              TOS *SP ADD,
              R1 TOS MOV,
              NEXT,
              END-CODE

\ ===================================================================
CR .(  B I N A R Y    O N   O F F )

CODE: ON      ( adr -- )
             *TOS SETO,          \ set all bits at adr to ones
              TOS POP,
              NEXT,
              END-CODE

CODE: OFF     ( adr -- )
             *TOS CLR,           \ 10+4 = 14
              TOS POP,           \       +22
              NEXT,              \ ----------
              END-CODE           \        36

\ ===================================================================
cr .( SKIP SCAN S= )

\ used CAMEL Forth MSP430 as reference code

\ ; Although SKIP, SCAN, and S= are perhaps not the ideal factors
\ ; of WORD and FIND, they closely follow the string operations
\ ; available on many CPUs, and so are easy to implement and fast.

\ used CAMEL Forth MSP430 as reference code

CODE: SKIP  ( c-addr u char -- c-addr' u')    \ skip matching chars
              TOS SWPB,                       \ fix this silly byte order. It took me hrs to realize this !@#$!
              2 (SP) W MOV,                   \ get address->w, leave space on stack
             *SP+ R1 MOV,                     \ POP count into R1, char is already in TOS
              NE IF,                          \ if r1=0 get out
                BEGIN,
                  TOS *W+ CMPB,               \ does character match? &  auto-incr. address
                  @@2 JNE,                    \ no, so we are done
                  R1 DEC,                     \ decr loop counter
                EQ UNTIL,                     \ try again
@@2:          W DEC,                          \ correct result address after auto-inc.
              ENDIF,
              W *SP  MOV,                     \ store updated address on stack
              R1 TOS MOV,                     \ updated count to TOS
              NEXT,
              END-CODE

CODE: SCAN   ( adr len char -- adr' len' )    \ find matching char
              TOS SWPB,                       \ silly machine needs this to compare memory to register
              2 (SP) W MOV,                   \ get address->w
             *SP+ R1 MOV,                     \ POP count into R1, char is already in TOS
              NE IF,                          \ R1<>0 ?
                 BEGIN,
                   TOS *W CMPB,               \ does character match?
                   @@2 JEQ,                   \ YES, we are done, JUMP OUT
                   W INC,                     \ next character
                   R1 DEC,                    \ dec. loop counter
                 EQ UNTIL,
              ENDIF,
@@2:          W *SP  MOV,                     \ store updated address on stack
              R1 TOS MOV,                     \ updated count to TOS
              NEXT,
              END-CODE

\ ========================================================================
\ adapted from Camel Forth MSP430.
\ TMS9900 does not have a SUBC instruction. I could not figure out how to do
\ the clever SUB with carry trick that Brad used on MSP430 so Old fashioned
\ jumps had to suffice.

CODE: S=  ( C-addr1 C-addr2 cnt1+1 -- n )      \ compare counted strings (1st byte is the length)
\      s1<s2 : n=-1:, s1=s2: n=0,  s1>s2 : n=1 \ slightly different than MSP430 version
              R2 POP,                          \ adrs2 -> R2
              R1 POP,                          \ adrs1 -> R1
              TOS R0 MOV,                      \ cnt -> R0
              NE IF,                           \ if count<>0 do search
                 TOS CLR,                      \ TOS=0 means we have a match
                 BEGIN,
                   *R1+ *R2+ CMPB,             \ compare char by char with 2 register auto incrementing
                    @@2 JNE,                   \ mismatch found, goto @@2
                    R0 DEC,                    \ decr. loop counter
                 EQ UNTIL,                     \ loop while R0 > 0
                 NEXT,                         \ match! Return to Forth.

@@2:          LT IF,   TOS INC,                \ R1<R2 set to 1
                 ELSE, TOS DEC,                \ R1>R2 set to -1
                 ENDIF,
              ENDIF,
              NEXT,                            \ Return to Forth
              END-CODE                         \ 30 BYTES

\ ========================================================================
\ D I C T I O N A R Y   S E A R C H
\ We found the Camel Forth dictionary search to be a little slow on TI-99.
\ Creating (FIND) in assembler is smaller and about 5X faster than using
\ S= plus hi-level looping and address calculation

\ Usage:
\  FIND ( c-addr -- caddr  0) if not found
\                   xt     1) if immediate,
\                   xt    -1) if "normal"
\             LATEST @ (FIND) ;

\ By using counted strings for input we get the bonus of comparing
\ the length bytes AND exiting the string compare loop after 1 compare
\ if the lengths are not equal. This makes for a fast traversal of
\ the linked list.

\ We also chose to take advantage of the large TMS9900 register set.
\ Therefore the input arguments are held in 3 registers and are
\ transferred to 3 new registers for the string compare loop.
\ This guarantees the fastest reload for each new string compare.

\ Register Usage
\ Inputs:  R3 = traverses NFAs in the Forth dictionary
\          R8 = address of the counted string we are looking for
\          R5 = length of the counted string in R8 + 1

\ string compare loop
\          R0 = number of characters to compare(search string length+1)
\          R1 = address of the 1st string to compare
\          R2 = address of the second string to compare

\ Outputs: R2 = address of found string -OR- address of search string on stack
\          R4 = Forth TOS register. Holds the true/false result flag


CODE: (FIND) ( Caddr NFA -- XT ? )
          TOS R3 MOV,                 \ R3 = NFA which is a counted string
          TOS CLR,                    \ TOS is the output flag, init to zero
         *SP R8 MOV,                  \ R8 = caddr which is a counted string
          NE IF,                      \ if count<>0 do the search
            \ get the length byte of Caddr
             *R8 R5 MOVB,             \ caddr C@ -> R5
              R5 8 SRL,               \ get the byte on the correct side right
              R5 INC,                 \ skip length byte
\ OUTER loop
            \ load char compare registers
              BEGIN,
                 R5 R0 MOV,           \ load R0 with length of caddr string
                 R8 R1 MOV,           \ load R1 with caddr string address
                 R3 R2 MOV,           \ load R2 with the NFA to compare

               \ inner character comparator loop
                 BEGIN,
                   *R1+ *R2+ CMPB,    \ compare char by char including the length byte
                    @@5 JNE,          \ ANY mismatch found, goto @@5
                    R0 DEC,           \ decr. loop counter
                 EQ UNTIL,            \ loop while R0 > 0
                 @@6 JMP,             \ WE FOUND IT!! exit the loop

               \ traverse link list to next NFA
@@5:             R3  -3 ADDI,         \ convert nfa>lfa
                *R3  R3 MOV,          \ do a fetch, R3 now has new NFA
              EQ UNTIL,               \ try the next word in the dictionary!
              NEXT,                   \ we got zero. End of the list! Go back to Forth
\ end Outer loop

\ convert NFA in R3 to CFA -> R2
@@6:          R3 R2 MOV,              \ if found R3 has a name field address (NFA), copy to R2
             *R3 R0 MOVB,             \ get the length of the name to R0
              R0 SWPB,                \ fix the #$%!@$ byte order again
              R0 R2 ADD,              \ add length to R2, gets past the string to the CFA
              R2 INCT,                \ inc 1 for the count byte and 1 more for even address evaluation
              R2 -2 ANDI,             \ align R2 to even address boundary

\ test for immediate or normal word -> TOS
              TOS SETO,               \ we found a word so set TOS to true
              R3 DEC,                 \ R3 has the NFA. NFA-1 is the immediate field
             *R3 R0 MOVB,             \ read contents of the immediate field
              NE IF,
                 TOS NEG,             \ if non zero negate the TOS from -1 to 1
              ENDIF,                  \ and head for home
          ENDIF,
          R2 *SP MOV,                 \ replace Caddr with the found XT in R2
          NEXT,                       \ Return to Forth
          END-CODE                    \ 42 BYTES

\ =======================================================================
CR ." V D P  C H I P  I N T E R F A C E"
\ We took a Forth approach to naming VDP memory routines.
\ So VSBR becomes VC@  and VSBW becomes VC!.
\ VMBW and VMBR become VWRITE AND VREAD.
\ We also added a new one V! and V@ that load and store 16 bit numbers to VDP.

\ And I embraced the Forth paradigm so these routines are created as
\ Forth words with stack based parameter passing. This gives us the freedom
\ to call these fast routines directly from Forth.
\ With these fast primitives we can write most of the VDP driver
\ in Forth and still get excellent performance.

\ factored sub-routines. Set up VDP address for write or read modes
l: WMODE      R0 4000  ORI,       \ set control bits to write mode (01)
l: RMODE      W  8C02  LI,        \ use byte reversed address, needs 1 less SWPB
              0 LIMI,
              R0 SWPB,            \ R0= VDP-adr we are using. Set up 1st byte to send
              R0 *W MOVB,         \ send low byte of vdp ram write address
              R0 SWPB,
              R0 *W MOVB,         \ send high byte of vdp ram write address
              2 LIMI,
              RT,

\ VSBR Forth style, on the stack
CODE: VC@     ( VDP-adr -- char )       \ Video CHAR fetch
              TOS R0 MOV,               \ VDP address into R0
              RMODE @@ BL,              \ set address in read mode
@@1:          VDPRD @@ TOS MOVB,        \ READ char from VDP RAM into TOS
              TOS 8 SRL,                \ move the damned byte to correct half of the word
              NEXT,
              END-CODE

CODE: V@     ( VDPadr -- n)             \ video fetch 16bit int
              TOS R0 MOV,               \ VDP address into R0
              RMODE @@ BL,              \ set address in read mode
              R3 VDPRD LI,              \ put the VDP read port address in R3. 12.9% faster
\              TOS CLR,
             *R3  TOS MOVB,             \ READ char from VDP RAM into TOS
              TOS SWPB,                 \ move byte to other side
             *R3  TOS MOVB,             \ READ 2nd char from VDP RAM into TOS
              TOS SWPB,                 \ put bytes in correct order for an integer
              NEXT,
              END-CODE

\ VMBR Forth style
CODE: VREAD   ( VDP-adr RAM-addr cnt  -- )
              R1 POP,                   \ pop buffer addr. to R1
              R0 POP,                   \ pop VDP addr. to R0
              R3 VDPRD LI,              \ put the VDP read port address in R3. 12.9% faster
              RMODE @@ BL,              \ call the RMODE control routine
              BEGIN,
                *R3 *R1+ MOVB,          \ READ char from VDP RAM into CPU RAM and autoINC
                 TOS DEC,               \ dec the counter
              EQ UNTIL,                 \ check if done
              TOS POP,                  \ refill TOS
              NEXT,
              END-CODE

\ ===================================================================
CR ." V D P   W R I T E"

\ VMBW in Forth style
CODE: VWRITE  ( RAM-addr VDP-addr cnt -- )
              R0 POP,                  \ vaddr to R0
              R1 POP,                  \ cpu addr to R1
              TOS TOS MOV,
              NE IF,                   \ protect from cnt=0 like CMOVE
                 WMODE @@ BL,          \ setup VDP write address
                 R3 VDPWD LI,          \ vdp addr. in a reg. makes this 12.9% faster
                 BEGIN,
                   *R1+ *R3 MOVB,      \ write byte to vdp write port
                    TOS DEC,           \ dec the byte counter
                 EQ UNTIL,             \ jump back if not done
              ENDIF,
              TOS POP,
              NEXT,
              END-CODE

CODE: VFILL   ( VDP-addr count char-- )
              TOS SWPB,                \ fix the TMS9900 byte order
              R2 POP,                  \ R2=count
              R0 POP,                  \ VDP-addr popped into R0
              WMODE @@ BL,             \ setup VDP write address IN R0
              R3 VDPWD LI,             \ vdp addr. in a reg. makes this 12.9% faster
              BEGIN,
                TOS *R3 MOVB,          \ write byte to vdp ram
                R2 DEC,                \ dec the byte counter
              EQ UNTIL,                \ jump back if not done
              TOS POP,
              NEXT,
              END-CODE

\ VSBW in Forth style  pronounced "Vee-Cee-store"
\ removed sub-routine call to speed up single byte writes
CODE: VC!     ( char Vaddr  -- )       \ Video CHAR store
              TOS R0 MOV,              \ need address in R0
              R0 4000  ORI,            \ set control bits to write mode (01)
              W  VDPWA  LI,
              0 LIMI,
              R0 SWPB,
              R0 *W MOVB,
              R0 SWPB,
              R0 *W MOVB,
              2 LIMI,
              TOS POP,                 \ get char into TOS register
              TOS SWPB,
              TOS VDPWD @@ MOVB,       \ write char to vdp data port
              TOS POP,                 \ refill TOS
              NEXT,
              END-CODE

CODE: V!     ( n Vaddr  -- )           \ Video store 16BIT int
              TOS R0 MOV,              \ need address in R0 to call WMODE
              WMODE @@ BL,             \ branch to setup VDP write address
              TOS POP,                 \ get char into TOS register
              R3 VDPWD LI,             \ vdp addr. in a reg. makes this faster
              TOS *R3 MOVB,            \ write hi byte to vdp data port
              TOS SWPB,                \ swap bytes
              TOS *R3 MOVB,            \ write lo byte to vdp data port
              TOS POP,                 \ refill TOS
              NEXT,
              END-CODE

\ * VDP write to register. Kept the TI name
CODE: VWTR    ( n reg -- )             \ Usage: HEX 0705 VWTR {write 5 to register 7}
              TOS R0 MOV,              \ changed to: 5 7 VWTR
              R0 8 SLA,                \ register goes to left side
             *SP+ TOS MOV,
              TOS 00FF ANDI,
              TOS R0 SOC,
              R0 8000 ORI,             \ set "write to register" mode bit
              RMODE @@ BL,
              TOS POP,
              NEXT,
              END-CODE

\ ===================================================================
\ T I - 9 9   S C R E E N   C O N T R O L  P R I M I T I V E S

CROSS-ASSEMBLING

\ *Variables to manage screen position *MOVED TO EQU file*
\ Since FORTH variables are just addresses, it is simple to to link these
\ addresses (ie Pointers) into the CAMEL 99 compiler.
\ Later, in the FORTH code we define these labels as CONSTANTS: so they return
\ their address to the top of the Forth stack.
\ Example:  _VROW CONSTANT: VROW        VROW now returns address _VROW to Forth
\ See: CAMEL99.hsf

\ These assembler routines manage the screen math at machine speed.
\ They are smaller and faster in ASM while still easy to understand.
\ Using these primitives and the VDP words CAMEL99 creates the rest of
\ video screen control in Forth.

\ CURSOR POSITION MANAGEMENT
 CODE: VPOS ( -- VDP-addr)   \ return current video position (screen address)
              TOS PUSH,               \ make some space
             _VROW @@ R3 MOV,
             _C/L  @@ R3 MPY,
             _VCOL @@ TOS ADD,        \ fetch _VCOL and add to TOS
              NEXT,
              END-CODE

CODE: (CR)    ( -- ? )  \ return true if we need to SCROLL
              TOS PUSH,
              TOS CLR,
             _OUT  @@ CLR,
             _VCOL @@ CLR,
             _VROW @@ INC,
              W  _L/SCR LI,
             _VROW @@ W CMP,
              EQ IF,
                  TOS SETO,
              ENDIF,
              NEXT,
              END-CODE

 CODE: (EMIT) ( char -- ?)  \ (emit) returns true if we need to goto newline
             _VROW @@ R1 MOV,
             _C/L  @@ R1 MPY,
             _VCOL @@ R2 ADD,           \ fetch _VCOL and add to R0 -> CURSORadr
              R2 R0 MOV,                \ cursoradr->R0
              WMODE @@ BL,              \ call: setup VDP address in "write mode"
              TOS SWPB,
              TOS VDPWD @@ MOVB,        \ write char to vdp data port
             _OUT  @@ INC,              \ count chars since last Carriage return
             _VCOL @@ INC,              \ advance the column variable

              TOS CLR,                  \ clear TOS. It' the output flag
             _C/L @@  _VCOL @@ CMP,     \ compare column variable to chars per line
              EQ IF,
                  TOS SETO,             \ set TOS to true, we need a new line
              ENDIF,
              NEXT,
              END-CODE

\ FAST variable for screen driver
CODE: C/L@   ( -- n )                  \ this is used 8 times in the KERNEL. Saves 14 bytes
             TOS PUSH,                 \ and is 50% faster than C/L @
            _C/L @@ TOS MOV,
             NEXT,
             END-CODE

\ make VCHAR go faster. clip vertical address value in VCHAR
CODE: VCLIP  ( lim char addr -- lim char addr)
             2 (SP) TOS CMP,
             LO IF,
                2 (SP) TOS SUB,
             ENDIF,
             NEXT,
             END-CODE
0 [IF]
\ high speed routine to support SPRITES (sum of squares)
\ moved to DIRSPRIT.FTH
CROSS-ASSEMBLING
CODE: DXY  ( x2 y2 x1 y1 --- distance^2 )  \ use by SP.DIST
            *SP+ R0 MOV,      \ pop x1->R0
            *SP+ TOS SUB,     \ pop y1-y2->tos
            *SP  R0 SUB,      \ x1-x2->R0, keep stack location
             TOS R3 MOV,      \ dup tos in r3, MPY goes into R4 for free!
             TOS R3 MPY,      \ r3^2, result->r4 (tos)
             R0  R2  MOV,     \ dup R0
             R2  R0  MPY,     \ RO^2
             R1 *SP  MOV,     \ result to stack
             NEXT,            \ 16 bytes
             END-CODE
[THEN]

\ ===================================================================
CR .( KEY?  and  ?TERMINAL)

\ Camel99 interface to KSCAN.
\ We used the ROM routine to test if a KEY was pressed only.
\ We read the character value from RAM with Forth code. See: KEY

CODE: KEY? ( -- ?)  \ *WARNING* it takes 1.15 mS for KEY? scan to run
             TOS PUSH,
             TOS CLR,            \ TOS will be our true/false flag
             0 LIMI,
             83E0 LWPI,          \ switch to GPL workspace
             000E @@ BL,         \ call ROM keyboard scanning routine
             8300 LWPI,          \ return to Forth's workspace , interrupts are restored
             837C @@ TOS MOVB,   \ read GPL status byte (=2000 if key pressed)
             2 LIMI,
             NEXT,               \ return
             END-CODE

\ *---------------------------------------------
\ * Call very fast built-in Fctn-4 test in console ROM
\   http://www.unige.ch/medecine/nouspikel/ti99/keyboard.htm
\ *---------------------------------------------
CODE: ?TERMINAL ( -- ?)    \ ~200uS, 16 bit ROM speed. Same name as TI-Forth
            R12     RPUSH,       \ save CRU address makes life simpler
            TOS     PUSH,
            TOS     CLR,
            0020 @@ BL,          \ Call ROM code, test FNCT 4 key press
            EQ IF,               \ if KEY pressed TOS = -1
               TOS SETO,
            ENDIF,
            R12     RPOP,        \ Restore CRU address used by CAMEL Forth
            NEXT,
            END-CODE


l: _CURSR   DATA 005F            \ holds the cursor character value default= '_'

CODE: CURS@   ( -- char)   \ return cursor or space for flashing cursor
            TOS PUSH,
           _CURSR @@ TOS MOV,    \ load the cursor char to TOS from memory
            8379 @@ W MOVB,      \ read interrupt timer to control flash speed
            W 1800 ANDI,         \ AND it with >18. This mask made a pleasant looking flash
            NE IF,               \ if = 0 then we return the cursor char
               TOS BL LI,        \ otherwise return a blank (space)  18 bytes
            ENDIF,
            NEXT,
            END-CODE

CODE: BYE    ( -- )
            0000 @@ BLWP,        \ ROM reset vector is at 0000
            END-CODE

\ CODE: LIMI0   0 LIMI, NEXT, END-CODE  \ disable interrupts
\ CODE: LIMI2   2 LIMI, NEXT, END-CODE  \ enable interrupts

\ ===================================================================
\ multi-tasking support
CODE: PAUSE   ( -- )             \ MULTI-TASKER switcher needed by I/O words in Kernel
            NEXT2 CFA!           \ patch CODE address with NEXT (replaced for multi-tasking)
            END-CODE

\ DSR Support
CODE: BLWP  ( vector -- )
           *TOS BLWP,
            TOS POP,
            NEXT,
            END-CODE

cr .( Code primitives complete)

