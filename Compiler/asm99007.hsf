\               _____  __  __   ___    ___    ___    ___
\       /\     / ____||  \/  | / _ \  / _ \  / _ \  / _ \
\      /  \   | (___  | \  / || (_) || (_) || | | || | | |
\     / /\ \   \___ \ | |\/| | \__, | \__, || | | || | | |
\    / ____ \  ____) || |  | |   / /    / / | |_| || |_| |
\   /_/    \_\|_____/ |_|  |_|  /_/    /_/   \___/  \___/
\
\


\ HsForth 2012 cross assembler for the TMS9900 cpu   July 1 2005 BJF
\ Based on TI-99 Fig Forth Assembler  circa 1987


\ ========================================================================
\ This file creates a Forth RPN style cross assembler for the TI TMS9900 CPU
\ It requires HSF2012 a 90% ANS compatible version of HS/Forth made by Brian Fox.
\ It makes use of HS/Forth's segment control words and therefore is not portable.
\ It is a copy of the TI-99/4A TI-Forth assembler adapted for use with HSF2012.
\ It assembles into a separate segment and has the ability to save a binary
\ image to a file.
\
\ The current version creates an "EA5" file for loading with option 5
\ of TI's Editor Assembler Cartridge for the TI-99.
\
\ Objective:
\ My goal in making this assembler is to improve the syntax of the original TI-99
\ Forth assembler and make it more like TI Assembler langauage while keeping Forth
\ RPN notation.
\
\ History:
\ July 1  2005 bugs bugs.
\ June 2 2006  added local labels like win32for
\        Note:   The original version used only structured branching and looping.
\                I added pre-defined labels that allow conventional branches and
\                but only for 10 labels (more can be defined). An example of how
\                to use the lables follows.  Labels ending with ':' can be used
\                only for destinations.  The same label without a colon is used
\                in the code with the appropriate JMP instruction.
\
\                *THESE LABELS CANNOT BE USED WITH BRANCH OR BRANCH&LINK INSTRUCTIONS.

\ Aug 11 2008    Replaced cross compiling section with work done on the Forth Cross compiler
\ Jun 13 2016    moved cross-compiler sections out to its own file: ti99xc2.hsf
\ Jun 21 2016    found missing "t," in "form1:" by reading the original sacred text from TiForth. :-)
\ Jul 19 2016    Changed TEXT" to TEXT.  Works just like TI Assembler now.
\                No count byte is in the Target.

\ Aug 28 2016    Major change: ORG address separate from EA5 file header!!
\                Did get it until I saw the memory in the debuffer at >A000
\                added HEADER@ which is 86 bytes before the ORIGIN. address
\                Allows the Forth compiler to find the correct addresses. Whew!
\ Sep 2 2016     After shifting load address to A000 all JMP instructions
\                would not forward branch!!  Found an error in BINDER:
\                " I ]ref @ 0 <> " was 0>.  Stupid mistake/
\ Oct 18 2016    After some minor maintenance the images will not work on Classic 99
\                Searching...
\ Oct 20 2016    Found the bug, but forgot to note what it was. Oops.
\ Jan 2 2017     Verions 5  works with version 5 of cross compiler
\                Now we create CAMEL Forth dictionary linkage so we can use CAMEL Forth code.
\                Added FILNAME:  directive for easier initialization of the file name
\ Apr 2020       Fixed ?HEADER to check for $DEAD in the field
\                Removed ABSOLUTE and RELOCATE. Never worked anyway.

\ ========================================================================

 [DEFINED] XASM
 [IF] CR
     CR .( *WARNING* Cross Assembler already loaded)
     CR .( compile halted)  ABORT

[THEN]

[UNDEFINED]  CROSS-COMPILER
[IF]   CR
       CR .( *WARNING* Cross compiler framework required.)
       CR .( needs TI99CX5.HSF   halt compile) ABORT
[THEN]

Create asmver ," Loading TMS9900 Cross Assembler V5.3 Apr 24 2020"

cr asmver $.

FORTH DEFINITIONS

: binary    2 base ! ;     \ useful in assembler


CROSS-ASSEMBLING XASSEMBLER DEFINITIONS

CREATE ASM_ERR_MSG
    ," "
    ," Bad jump token"                                  \ 1
    ," Allocate past end of memory"                     \ 2
    ," Invalid Register"                                \ 3
    ," Missing arguments"                               \ 4
    ," too many labels created"                         \ 5
    ," Jump out of range (+127..-127)"                  \ 6
    ," R0 CANNOT do indexed addressing"                 \ 7
    ," Too many arguments for this instruction"         \ 8
    ," Program bigger that 8K"                          \ 9
   ," "                                                 \ null


: ]ASMERR   ( ? n -- )
           dup 1 9 within? not abort" Unknown ASM error"

           CR ." XASSEMBLER ERROR #" DUP .
           CR ASM_ERR_MSG .NTH$
           TRUE ABORT" Cross Assembler Halted" ;


VARIABLE (OLDCONTEXT)          \ temp storage for context vocabulary


cr .( Data directives)
\ ========================================================================
\ X A S S E M B L E R   D I R E C T I V E S

: .EVEN  ( -- ) TALIGN ;                \ place XASSEMBLER program counter on an EVEN address




\ ========================================================================
\ R P N  D A T A  D I R E C T I V E  P R I M I T I V E S

: DATA,   ( n -- )   T, ;               \ RPN version of DATA for 1 word
: BYTE,   ( n -- )   TC, ;              \
: BYTES,  ( n -- )
          THERE OVER 0 TFILL TALLOT TALIGN ;   \ fill & allot the memory

: TEXT,   ( addr len -- )
          DUP >R
          THERE SWAP TCMOVE
          R> TALLOT
          TALIGN ;                      \ always leave dictionary pointer on an even address




\ ========================================================================
\ T M S 9 9 0 0   A S S E M B L E R   B E G I N S

cr .( Define registers)

decimal
00 constant R0
01 constant R1
02 constant R2
03 constant R3
04 constant R4
05 constant R5
06 constant R6
07 constant R7
08 constant R8
09 constant R9
10 constant R10
11 constant R11
12 constant R12
13 constant R13
14 constant R14
15 constant R15

HEX

cr .( Addressing modes)

\ ========================================================================
\ S Y M B O L I C  ( D I R E C T )  A D D R E S S I N G   M O D E

: @@    020   ;                \ that's all there is! :-)


\ ========================================================================
\ Addressing modes primitives.  Not Normally used in code
: $10+ ( reg -- code) 010 + ;
: $30+ ( reg -- code) 030 + ;
: ()   ( reg -- code) 020 + ;


\ Using the primitives I am defining register names WITH addressing mode because
\ in HSF2000 I have plenty of name space and it will make the assembler look
\ more like standard TI assembly language.  Examples shown below.

\ ========================================================================
\ I N D I R E C T   A D D R E S S I N G

: *R0    ( -- n) R0 $10+ ;
: *R1    ( -- n) R1 $10+ ;
: *R2    ( -- n) R2 $10+ ;
: *R3    ( -- n) R3 $10+ ;
: *R4    ( -- n) R4 $10+ ;
: *R5    ( -- n) R5 $10+ ;
: *R6    ( -- n) R6 $10+ ;
: *R7    ( -- n) R7 $10+ ;
: *R8    ( -- n) R8 $10+ ;
: *R9    ( -- n) R9 $10+ ;
: *R10   ( -- n) R10 $10+ ;
: *R11   ( -- n) R11 $10+ ;
: *R12   ( -- n) R12 $10+ ;
: *R13   ( -- n) R13 $10+ ;
: *R14   ( -- n) R14 $10+ ;
: *R15   ( -- n) R15 $10+ ;

\ ========================================================================
\ I N D I R E C T   A D D R E S S I N G ,  A U T O - I N CR E M E N T

: *R0+   ( -- n) R0 $30+ ;
: *R1+   ( -- n) R1 $30+ ;
: *R2+   ( -- n) R2 $30+ ;
: *R3+   ( -- n) R3 $30+ ;
: *R4+   ( -- n) R4 $30+ ;
: *R5+   ( -- n) R5 $30+ ;
: *R6+   ( -- n) R6 $30+ ;
: *R7+   ( -- n) R7 $30+ ;
: *R8+   ( -- n) R8 $30+ ;
: *R9+   ( -- n) R9 $30+ ;
: *R10+  ( -- n) R10 $30+ ;
: *R11+  ( -- n) R11 $30+ ;
: *R12+  ( -- n) R12 $30+ ;
: *R13+  ( -- n) R13 $30+ ;
: *R14+  ( -- n) R14 $30+ ;
: *R15+  ( -- n) R15 $30+ ;


\ ========================================================================
\ I N D E X E D   M E M O R Y   A D D R E S S I N G

: (R0)    7 ]ASMERR ;       ( R0 cannot be used as an index register)
: (R1)    R1 () ;
: (R2)    R2 () ;
: (R3)    R3 () ;
: (R4)    R4 () ;
: (R5)    R5 () ;
: (R6)    R6 () ;
: (R7)    R7 () ;
: (R8)    R8 () ;
: (R9)    R9 () ;
: (R10)  R10 () ;
: (R11)  R11 () ;
: (R12)  R12 () ;
: (R13)  R13 () ;
: (R14)  R14 () ;
: (R15)  R15 () ;


\ ========================================================================
\ A S M 9 9 0 0   C O D I N G   E X A M P L E S

\  Description                   ASM9900   Usage      TI Syntax Equivalent
\  ------------                 -------------------   --------------------
\                                 src.     dst.               src.     dst.
\                                 ----     ----               ----     ----
\ symbolic addressing:            VAR1 @@  R12 ADD,     A    VAR1@,    R12
\ Register indirect addressing:  *R13      R2  MOV,     MOV *R13,      R2
\ Register indirect auto-incr.:  *R13+     R2  MOV,     MOV *R13+,     R2

\                                HEX
\ create an array:            l: ARRAY   BSS  100 2 *   ARRAY   BSS >100*2

\ Indexed memory addressing      ARRAY (R13) R2 MOV,    MOV @ARRAY(R13),R2

\ ========================================================================
\ G E N E R A L  O P E R A T I O N  I N S T R U C T I O N  C R E A T O R

: ADDR? ( n -- ? )         \ true if n is an address; false if a register
        DUP 1F > SWAP 30 < AND ;

cr .( Creating instructions)

\ TMS9900 has 9 instruction formats. Ref: "9900 Reference Data Appendix 6"

\ primitive to create "program" instructions that are "format 6"
: format6, ( argument, instruction -- )
        OVER addr?                    \ check if arg is register or address
        IF      + t, t,
        ELSE    + t,
        THEN ;

: GENOP:
    CREATE ,
    DOES> @ format6, ;

\ create some tms9900 instructions
0440 GENOP: B,        \ branch to address
0680 GENOP: BL,       \ branch and link (sub-routine call, 1 level deep ONLY!)
0400 GENOP: BLWP,     \ branch and load workspace pointer, 1 level deep only!)
04C0 GENOP: CLR,      \ clr a register
0700 GENOP: SETO,     \ set to ONES
0540 GENOP: INV,      \ invert
0500 GENOP: NEG,      \ negate
0740 GENOP: ABS,      \ ABS
06C0 GENOP: SWPB,     \ swap bytes
0580 GENOP: INC,      \ increment by 1
05C0 GENOP: INCT,     \ increment by 2
0600 GENOP: DEC,      \ decrement by 1
0640 GENOP: DECT,     \ decrement by 2
0480 GENOP: X,        \ Execute instruction at address


\ ========================================================================
\ G E N E R A L  R E G I S T E R  O P E R A T I O N S  " F O R M A T  1 "

: form1:
    CREATE ,
    DOES>   @ SWAP DUP  ADDR?
            IF      40 * + SWAP >R format6,      \ compile the instruction
                    R>  T,                       \ compile the address
            ELSE
                    40 * + format6,              \ compile the instruction using register args
            THEN ;


A000 form1: ADD,        \ Changed from TI assembler 'A' to ADD
B000 form1: ADDB,       \ Changed from TI assembler 'AB' to ADDB

8000 form1: CMP,        \ changed from TI 'C' to CMP,  for clarity
9000 form1: CMPB,       \ changed from TI 'CB' to CMPB,  for clarity

6000 form1: SUB,        \ Changed from TI assembler 'S' to SUB,
7000 form1: SUBB,       \ Changed from TI assembler 'SB' to SUBB,

E000 form1: SOC,        \ "SET ONES CORRESPONDING" These are Logical OR instructions with stupid names
: OR,    SOC, ;         \ BF alias: "Set ones corresponding" is a logical OR

F000 form1: SOCB,       \ "SET ONES CORRESPONDING" in a byte
: ORB,   SOCB, ;        \ BF alias:  'OR byte'

4000 form1: SZC,        \ "Set zeros corresponding"

5000 form1: SZCB,       \ "Set zeros corresponding" in a BYTE

C000 form1: MOV,        \ Move
D000 form1: MOVB,       \ move byte

\ ========================================================================
\ J U M P   O P E R A T I O N S    " F O R M A T  2 "

\ address cannot be more that +/- 127 bytes from the current program counter

: JMPOP:
    CREATE ,
    DOES> ( offset -- )
        @ ( -- offset op-code)   \ fetch op-code from the word's memory
        SWAP dup  abs 00FF >     \ make sure offset is in range.
        if  6 ]asmerr then
        1- 00FF AND OR T, ;

HEX
1000 JMPOP: JMP,
1100 JMPOP: JLT,                \ <                signed
1200 JMPOP: JLE,                \ low or equal     signed
1300 JMPOP: JEQ,                \ =                signed
1400 JMPOP: JHE,                \ high or =        signed
1500 JMPOP: JGT,                \ >                signed
1600 JMPOP: JNE,                \ <>               signed
1700 JMPOP: JNC,                \ no carry
1800 JMPOP: JOC,                \ on carry
1900 JMPOP: JNO,                \ no overflow
1A00 JMPOP: JL,                 \ low              un-signed
1B00 JMPOP: JH,                 \ high             un-signed
1C00 JMPOP: JOP,                \ on parity

cr .( prenamed jump labels)
\ ========================================================================
\ P R E N A M E D   L O C A L   J U M P  L A B E L S

\ Concept taken from Win32Forth assembler.

\ Using these labels makes it simpler to translate existing TI Assembler
\ code to XASM99 RPN Assembler code.

\ These labels are 2 forms:  a 'refer'  and a 'binder'
\ refer: creates a destination label for a jump
\ binder creates a matching label for the 'refer:' labels.
\ Example code is shown below.

\ *NOTE: These are ONLY for use with JMPOP: instructions ABOVE.
\ ie: "program counter relative addressing mode"

\ for Branching with B, BL, or BLWP create a LABEL with L: <text>

HEX 30 value jmptab-size   \ room for 24 labels

jmptab-size cells BUFFER: REF       \ jump address place holders
jmptab-size cells BUFFER: BIND

: clr-jmptable
        ref  jmptab-size cells erase          \ clear the ref jump table
        bind jmptab-size cells erase ;        \ clear the bind jump table


\ resolve DEFERred word from Cross-compiler

' CLR-JMPTABLE IS NEW-JMPTABLE

\ simple arrays for forward references
: ]ref  ( ndx -- adr ) cells ref + ;
: ]bind ( ndx -- adr)  cells bind + ;

: >offset ( n -- byte)        \ convert n to a valid TMS9900 jump offset
       DUP ABS  0FF U< not
       if
          cr ." Jump offset= " decimal 2/  3 .r
             6 ]asmerr
       then
       2/ 1+  0FF and  ;


: ]fwd-calc ( ndx -- byte)
        >r
        R@ ]bind @  R@ ]ref @ -  2- >offset
        rdrop ;

: ]bwd-calc ( ndx -- byte)
       >r
       R@ ]bind @  R@ ]ref @  -  >offset
       rdrop ;

: refer:  ( n -- <label> ) \ create a destination label for Jump intructions
        create  ,                \ record the index #
        does>   @ >R  ( -- c)
                THERE R@ ]ref !
                R@ ]bind @ 0 <>  ( there is a bind so this is a backward jump)
                if
                    R@ ]bwd-calc  ( -- offset)
                else
                    0
                then
                rdrop ;

: binder: ( n --<label> ) \ create a binder label for fwd references
        create  ,         \ record the index #
        does>   @ >R
                THERE 2- R@ ]bind !  \ store the address where BINDER is first found
                R@ ]ref @ 0 <>       \ there is a reference in the code so this is a forward jump
                if
                   R@ ]fwd-calc ( offset) R@ ]ref @ 1+  ( -- offset addr) TC!
                then
                rdrop ;

\ now we can create some labels (can't ever imagine needing 9 labels in a code word that I write)
1 refer: @@1    1 binder: @@1:
2 refer: @@2    2 binder: @@2:
3 refer: @@3    3 binder: @@3:
4 refer: @@4    4 binder: @@4:
5 refer: @@5    5 binder: @@5:
6 refer: @@6    6 binder: @@6:
7 refer: @@7    7 binder: @@7:
8 refer: @@8    8 binder: @@8:
9 refer: @@9    9 binder: @@9:


\ ========================================================================
\ P R E N A M E D  L A B E L   U S A G E   E X A M P L E

\  These 2 pieces of code below should assemble to the same object code
\  even though they use completely different branching semantics

\ code: test1            \ backward jumps tested OK  May 2006
\           begin,
\             R7 1000 ADDI,
\             R7 R1 CMP,
\             GTE IF,
\                R6 R6 CLR,
\             ENDIF,
\             R8 R7 SUB,
\           again,
\           end-code

\ code test2
\ @@1:      R7 1000 ADDI,          \ begin
\           R7 R1 CMP,
\           @@2 JL,                \ GTE if
\           R6 R6 CLR,
\ @@2:      R8 R7 SUB,
\           @@1 JMP,               \ again
\           end-code


\ ===================================================================
\ P R O G R A M   C O U N T E R   A D D R E S S I N G

\ This is part of the TI assembler so I include it here for completeness
\ It can be handy to provide an endless loop to FREEZE a program to debug
\ Example of endless loop:  0 +$$ jmp,

: +$$  ( n -- offset ) 2- >offset ;    \ +$$ returns the value of program counter+n

: $$   ( -- ) 0 +$$ ;

\ TI ASSEMBLER      ASM9900 equivalent
\ ------------      ------------------
\  JLT  $+4            4 +$$  JLT,        Jump 4 bytes down on less than condition
\  JMP  $-120       -120 +$$  JMP,        Jump 120 bytes up
\  JMP $                  $$  JMP,        Jump to current location

\ ===================================================================
\ Z E R O   O P S     " F O R M A T   7"

: ZOP:
    create ,
    does> @ t, ;

0340 ZOP: IDLE,
0360 ZOP: RSET,
03C0 ZOP: CKOF,
03A0 ZOP: CKON,
03E0 ZOP: LRET,
0380 ZOP: RTWP,

\ ===================================================================
\ R E G I S T E R   O P E R A T I O N S   " F O R M A T   8"

: RegOP   CREATE ,  DOES> @ + t, ;

02C0 RegOP STST,      \ store status register
02A0 RegOP STWP,      \ store workspace pointer


\ ===================================================================
\ F O R M A T   9   I N S T R U C T I O N S
: form9:
        create ,
        does> @ swap 40 * + format6, ;

2000 form9: COC,
2400 form9: CZC,
2800 form9: XOR,
2C00 form9: XOP,
3800 form9: MPY,
3C00 form9: DIV,

\ ===================================================================
\ I M M E D I A T E   O P E R A T I O N S

: IOP
    CREATE ,
    DOES> @ t, t, ;

02E0 IOP LWPI,      \ Load workspace pointer immediate
0300 IOP LIMI,      \ Load interrupt mask immediate

\ ===================================================================
\ R E G I S T E R   I M M E D I A T E   O P E R A T I O N S

: RIOP:
    CREATE ,
    DOES> @ ROT +  t,      \ compile the instruction
           ( data) t, ;    \ compile the immediate operand

0220 RIOP: ADDI,                \ changed from AI to ADDI for consistentcy
0240 RIOP: ANDI,                \ changed to ANDI for consistentcy
0280 RIOP: CMPI,                \ changed from CI to CMPI for consistentcy
0200 RIOP: LI,
0260 RIOP: ORI,

\ ===================================================================
\ Register operations

: RSOP:
    CREATE ,
    DOES> @ SWAP 10 * + + t, ;

0A00 RSOP: SLA,
0800 RSOP: SRA,
0B00 RSOP: SRC,
0900 RSOP: SRL,

\ ===================================================================
\ CRU operations

: bitOP:     ( format 2)
    CREATE ,
    DOES> @ SWAP 00FF AND OR t, ;

1D00 bitOP: SBO,
1E00 bitOP: SBZ,
1F00 bitOP: TB,

: cruop:
    create ,
    does> @ swap 000F and 6 lshift ( 40 *) + format6, ;  \ change 40 * to lshift

3000 cruop: LDCR,
3400 cruop: STCR,


\ ===================================================================
\ P S E U D O   I N S T R U C T I O N S  (like TI assembler)

: RT,      *R11 B, ;              \ return from subroutine call
: NOP,     2 +$$ jmp, ;           \ jump to the next instruction

0 [IF]

\  *****   MOVED TO TARGET COMPILER FILE *****
\ ===================================================================
\ T M S 9 9 0 0   N E X T   R O U T I N E

\ By defining NEXT as a deferred word you can change it easily

DEFER NEXT,   \ next, MUST be defined as a FORTH word (macro) in your CODE

\ EXAMPLE:
\ : 9900next,
\        *R10 B, ;  ( assumes address of NEXT is in R10)

\  ' 9900next, is NEXT,

\ ===================================================================
[THEN]

cr .( Hi Level flow control)
\ hi level program flow control ........................................
HEX
: ?exec
        state @ 0 <> abort" Cannot be used while compiling" ;

\ Jump tokens for use with CJMP
HEX
 1 CONSTANT GTE     \ GT OR EQUAL
 2 CONSTANT HI      \ JMP IF HI
 3 CONSTANT NE      \ NOT equal
 4 CONSTANT LO      \ jmp if low
 5 CONSTANT LTE     \ jmp if less than or equal
 6 CONSTANT EQ      \ jmp if equal
 7 CONSTANT OC      \ jmp on carry flag set
 8 CONSTANT NC      \ jmp if no carry flag set
 9 CONSTANT OO      \ jmp on overflow
 A CONSTANT HE      \ jmp high or equal
 B CONSTANT LE      \ jmp if low or equal
 C CONSTANT NP      \ jmp if no parity ?
 D CONSTANT LT      \ jmp if less than  (SIGNED)
 E CONSTANT GT      \ jmp if greater than (SIGNED)
 F CONSTANT NO      \ jmp if no overflow
10 CONSTANT OP      \ jmp if ODD parity

: CJMP CASE
         LT OF 1101 T, 0 ENDOF
         GT OF 1501 T, 0 ENDOF
         NO OF 1901 T, 0 ENDOF
         OP OF 1C01 T, 0 ENDOF
         DUP 0< OVER 10 > ABORT" IF, BAD jump token"
       ENDCASE CSWAP 1000 + T, ;


\ *These words do compile time matching*

\ 42 the meaning of life the universe and everything
\ is use to check that if, else, endif, are used properly
\ each word leaves 42 or checks for it's presence as neeeded
\ using the word ?pairs to test for completeness

: if,
        ?exec
         cjmp THERE 2- 42 ; immediate

: endif,
        ?exec
        42 ?pairs
        THERE over - 2- 2/ swap 1+ tc! ; immediate

: else,
        ?exec
        42 ?pairs
        0  cjmp THERE 2- swap
        42 [compile] endif,  42 ;  immediate

: begin,
        ?exec
        THERE 41 ; immediate

: until,
        ?exec
        swap 41 ?pairs
        cjmp THERE - 2/ 00FF and
        THERE 1- tc! ; immediate

: again,
        ?exec
        0 [compile] until, ;  immediate

: repeat,
        ?exec
        >r >r    [compile] again,
        r> r> 2- [compile] endif, ;  immediate

: while,
        ?exec
        [compile] if,  2+ ;  immediate

\ =========================================================================
\ T I - 9 9   S P E C I F I C   D I R E C T I V E S
\ =========================================================================

\ simple machine code dump utility for debugging
\ t' ! .code

HEX 045A CONSTANT 'NEXT'  \ code for:  *R10 B,

: ?newline
        out @ c/l @ 0A - > if CR TAB then ;

: .ticode  ( taddr -- )  \ print the machine code for a Forth code word
        CR ." CODE " DUP .####
        CR  TAB
        100 BOUNDS
        DO
           [TARGET] I @L CSWAP
           DUP 'NEXT' =
           IF  DROP LEAVE
           ELSE  ?newline .#### ."  , "
           THEN
           CELL+
        2 +LOOP
        CR TAB ." NEXT,"
        CR ." END-CODE"  ;

\ =========================================================================
\ T I - 9 9   E A 5   F I L E   F O R M A T   S E C R E T S

\ Menu option 5 of the Editor/Assembler cartridge loads and runs a binary
\ file. Hence the name "EA5".

\ Docs say "There is a 3-word header that contains instructions for the loader."

\ BUT!!!
\ There is an extra header used for files on a PC called V9T9 format.
\ So.. you have to create the V9T9 header in your memory image too !!!

\ Sept 27, 2018: I now know more abit the V9T9 FORMAT.
\ Here is the back story from Arcadeshopper on Atariage.com
\ History:
\ "When we started uploading files to BBS's they had to come up with a way to
\ store TI specific file header information.. SO the TIFILES header was
\ created which prepends the file with the information needed to store it correctly.
\ V9T9 came out (perhaps the first TI emulator (for DOS!)) and it needed a way
\ to store files on the PC drive with the TI directory information as well,
\ so instead of using the standard, they made up their own.."

\ Actual Header of DEMO file from Classic99 Emulator
\ ----------------------------------------------------------------------------
\ 2D9B:0000  44 45 4D 4F 20 20 20 20  20 20 00 00 01 00 00 20  DEMO      .....  <----first 10 bytes contain the file name)
\ 2D9B:0010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
\ 2D9B:0020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
\ 2D9B:0030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
\ 2D9B:0040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
\ 2D9B:0050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
\ 2D9B:0060  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
\ 2D9B:0070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................ <--- V9T9 header ends here
\ 2D9B:0080  FF FF 20 00 A0 00 04 60  CC 00 C8 0B A1 0E 02 02  .. ....`........
\            ^     ^     ^     ^
\ more flag--|     |     |     |______CODE STARTS HERE.
\ file size--------      |            This compiler puts a Branch instruction here by default.
\          load address -
\

\ The standard EA5 header structure is the following:
\       Address         Content
\      ----------       ------------------------------------------------------
\       >0080           FILE LOAD Flag. >0000 = last file. >FFFF = load one more file
\       >0082           Number of bytes to load (not counting these 6).
\       >0084           Absolute Load Address in TI-99 memory
\ B Fox extended header
\       >0086           BRANCH symbolic intruction @>0008
\       >0088           contains start address of program. (Filled in by PROGRAM: or SET-BOOT DIRECTIVES)

\ The loader loads the specified number of bytes, taken directly after to the
\ header, to the specified address in memory. If the flag word is >FFFF, the
\ loader then loads another file whose name is coined by incrementing by 1 the
\ last character of the current file name. This process goes on until a file
\ with a >0000 flag is loaded. At this point, the loader executes the program
\ by performing a BL to the address where the first program was loaded.

\ The workspace upon entry will be >20BA with the Editor/Assembler cartridge,
\ but the program should not take this for granted since other loaders may use
\ a different workspace. Similarly, it may be wise for a program to properly
\ setup the VDP memory, rather than to assume that the Editor/Assembler
\ cartridge has already done it.

\ A program can return to the caller with B *R11 IF you are in the same
\ workspace that was used when the program was loaded. (not likely)
\ Better to reset the TI-99/4A with BLWP @>0000.
\ ===================================================================



\ ========================================================================
\ A D D R E S S E S

VARIABLE org-addr         \ holds the TI-99 address that the code is loaded to

: org-addr! ( Taddr -- ) org-addr ! ;
: org-addr@ ( -- Taddr ) org-addr @ ;

64K org-addr!              \ init to 64k ( -1) to detect if it has not been set

HEX 86 constant header-size     \ TI-99 E/A5 file header size

: header@   ( -- Taddr ) org-addr@ header-size - ; \ addr of start of program header

\ ========================================================================
\ TI EA5 file image header addresses

HEX 2000 80 + EQU MAX-PROG           \ 8K bytes is a big as we can go with each E/A5 files

\ TI-99 E/A5 file format header is 6 cells.
\ these are the offsets from the header base
0000 EQU ->file-name
0080 equ ->more-field
0082 equ ->PROG-SIZE
0084 equ ->load-field

\ B.Fox addtition to the header....
0086 equ ->entry-field            \ JUST contains a branch instruction
0088 equ ->BOOT-address           \ TARGET address offset that contains the address that we branch to at startup


\ ========================================================================
\ create relocatable target variables in the header
: file-name    ( -- Taddr) header@ ->file-name + ;
: PROG-SIZE    ( -- Taddr) header@ ->prog-size + ;
: more-field   ( -- Taddr) header@ ->more-field + ;
: LOAD-FIELD   ( -- Taddr) header@ ->load-field +  ;
: ENTRY-FIELD  ( -- Taddr) header@ ->entry-field +  ;
: BOOT-ADDRESS ( -- Taddr) header@ ->boot-address + ;

\ ========================================================================
\ test the header fields to know the program is correct
: ?file-name    ( -- ) file-name tc@ FF = ABORT" Missing FILENAME: directive" ;
: ?prog-size    ( -- ) prog-size    t@ BEEF = ABORT" Program size is not set" ;
: ?more-field   ( -- ) more-field   t@ 0=  prog-size t@ MAX-prog > AND abort" MORE-FIELD err. Image>8K" ;
: ?load-field   ( -- ) load-field   t@ DEAD = ABORT" IMAGE has no LOAD address at offset HEX 84" ;
: ?entry-field  ( -- ) entry-field  t@ 0<     ABORT" TI-99.EA5 directive is missing in the code" ;
: ?boot-address ( -- ) boot-address t@ DEAD = ABORT" IMAGE requires a boot address" ;

\ test them all!
: ?header       ( -- )
                ?file-name ?prog-size  ?more-field  ?load-field  ?entry-field  ?boot-address ;

\ ========================================================================
\ C R E A T E  A  L A B E L
\ usage:  l: endop      R0+ R1 mov,
\                       endop  b,    ( endless loop created)

\ creates a label in HOST Forth that returns a TARGET address when executed
: l: ( -- <label> )
      CREATE  THERE ,
      DOES> @                        \ interpreting ( -- Taddr)
\             XSTATE @               \ cross-compiler is on, compile as literal
\             IF  'LIT T,  T,  THEN  \ 'lit needs to be resolved before use :-(
 ;



\ ========================================================================
\ B L O C K   S T A R T I N G   S E G M E N T

\ I have made BSS work like TI, but it evaluates Forth so math is RPN

\ Usage:
\              ASM9900                  TI ASSEMBLER
\ DECIMAL
\ l: scrbuf    BSS 24 32 *           SCRBUF   BSS 24*32
\ l: buffer    BSS HEX 100           BUFFER   BSS >100


: BSS         ( n -- <text-name> )
              1 parse evaluate ( n) bytes, ; \ Parse up to Carriage return,
                                             \ allocate the space and fill with zeros

\ ========================================================================
\ D A T A  D I R E C T I V E S
\ works like TI ASSEMBLER ie: multiple numbers per line
\ DATA[ ... ]DATA only accepts numbers

: <FRAME>    ( -- )   !CSP ;           \ mark beginning of a stack frame
: </FRAME>  ( n..n' -- ) CSP @ SP!  ;  \ collapse stack frame

: DATA[    ( -- <text string>)  <FRAME> .EVEN ;  \ always starts on even address

: ]DATA    ( n..n[x] -- )
            0 DEPTH 1-
            DO
              I PICK data,
            -1 +LOOP
            </FRAME> .EVEN ;                \ always ends on even address

: DATA      ( -- <TEXT> )  1 PARSE EVALUATE  data, ;

\ ========================================================================
\ B Y T E   D I R E C T I V E
\ works like TI ASSEMBLER ie: multiple bytes per line
\ BYTES[ ... ]BYTES only accepts numbers

: BYTES[    ( -- <text string>) <FRAME> ;

: ]BYTES    ( n..n[x] -- ) 0 DEPTH 1- DO  I PICK  byte,  -1 +LOOP </FRAME> ;

HEX
: BYTE      ( -- <text>)
            1 PARSE EVALUATE
            DUP 00FF > ABORT" BYTE too big"
            byte, ;



\ ========================================================================
\ T E X T   D I R E C T I V E
\ works like TI ASSEMBLER but uses double quotes.

\ Usage:      TEXT "Puts this string into memory"   \

: TEXT      ( -- "text")
            "WORD DROP                       \ parse upto 1st quote and drop it
            [CHAR] " PARSE TALIGN TEXT, ;    \ parse remaining text and compile to memory

: TEXT'     CHAR ' PARSE TALIGN TEXT, ;      \ usage:  (mind the first space) text' text

: STRG"     TALIGN [CHAR] " PARSE THERE TPLACE TALIGN ;  \ places a counted string in memory (even addresses)


DECIMAL
: SAVE-BIN.  ( FILENAME$ -- )   \ save binary image of cross assembled program
        PUSH$ LEN 0= ABORT" SAVE-BIN: need file name"
        cr ." Saving " TOP$ COUNT TYPE ."  ... "
        [target] TOP$ put-file
        cr ." File saved, "  [target-img seg-ptr] ? ." bytes"
        cr
        collapse ;

\ ========================================================================
\ S U B - R O U T I N E  C R E A T I O N

\ sub: routines create a name in the compiler but not in the TARGET Forth

: SUB:  ( <text>) ( -- )
        !csp                    \ record the stack position
        clr-jmptable            \ empties the jumptable so you can use all the labels
        TALIGN l:   ;           \ sub: creates the label ALWAYS on an even address boundary


: END-SUB  ?csp  ;              \ checks for "leftovers" on the stack


\ ========================================================================
\ C R O S S - A S S E M B L E R   D I R E C T I V E S

\ moved these to the cross-compiler vocabulary because it made more sense

CROSS-COMPILING

: START.                        \ reset the timer to time the assembly operation
        timer-reset ;

variable ORGFLAG

: SET-ORG  ( n -- )
            DUP header-size - tdp !  \ set dictionary pointer 86 bytes back for the header
           ( DUP) org-addr!          \ this will also be the actual load address in TI-99
              0 XLATEST !  ;          \ LASTEST var must begin at the same place for dictionary links to work

: ORIGIN.  ( n -- )

        DUP TDP @ U<
        if
          CR ." *WARNING* ORIGIN. has been moved backwards"
        then cr
        dup SET-ORG
        ORGFLAG ON
        CR ." ORIGIN. has been set to " hex 4 U.R ;

HEX
: NEW.
        0 64k FF TFILL          \ fill the cross compiler 64k mem space with $FF
        0 TDP !                 \ set ORG to 0
        NEW-jmptable
        Tcodewords off
        tforthwords off
        64k org-addr ! ;        \ mark the load address to end of segment ie: not set correctly


\ =========================================================================
\ CROSS-COMPILING  ;C O D E
0 [if]
CROSS-COMPILING

\
\ adapted from Moving Forth by Dr. Brad Rogridguez  Many thanks!
\

host: t(;CODE)
                R>                  \ pops the adr of the machine code
                LATEST @ nfa>cfa    \ gets the CFA of the latest word
                T!                  \ stores the code address in the TARGET Code Field
;host


host: ;CODE
                TCOMPILE t(;CODE)       \ compiles t(;CODE) into definition
                ?CSP COMPILE T[     \ turns off the Forth compiler (just like ";" does)
                TREVEAL
                CROSS-ASSEMBLING    \ turns on the CROSS-assembler
;host IMMEDIATE
[then]

cr .( TI-99 file control directives)
\ ===========================================================================*
\ T I   F I L E   H E A D E R   F O R   E A 5   F O R M A T

\ EA5 means "EDITOR ASSEMBLER, MENU OPTION 5

\ I have extended the header by 2 words.
\ The very first instruction that runs is a branch to the entry address.


HEX
\ create the "Editor Assembler 5" binary program header in the memory image
\ This code adds a 2 byte branch instruction as the first code that runs
\ so you can jump to a startup routine anywhere in memory

: TI-99.EA5  ( -- )
        orgflag @ 0= ABORT" missing ORIGIN. directive"   \ ORIGIN. directive MUST precede this directive to set the load address
        header@ DUP  header-size 0 tfill                 \ init header memory with zero
        ( -- addr ) 0A BL TFILL  0A TALLOT               \ FILL space for the file name with blanks (for debugging)

        0000 T,                                          \ lay in some data after the FILENAME
        0100 T,                                          \ don't know what these numbers do...?
        0020 T,                                          \ TI-99 FIXED/80 file format code?

        70 TALLOT                                        \ move pointer to end of header

        FALSE DATA,                                      \ the "MORE-FIELD"= true (-1) if there are more files to load
        BEEF DATA,                                       \ place holder for the PROG-SIZE  (in bytes)
        ORG-ADDR@ DATA,                                  \ record the load address in the file
        DEAD @@ B,                                       \ 2 BYTES:  branch to address where the program starts
;

: TIFILES.EA5  ( -- )
        orgflag @ 0= ABORT" missing ORIGIN. directive"   \ ORIGIN. directive MUST precede this directive to set the load address
        header@ DUP  header-size 0 tfill                 \ init header memory with zero
        ( -- addr ) 0A BL TFILL  0A TALLOT               \ FILL space for the file name with blanks (for debugging)

        0000 T,                                          \ lay in some data after the FILENAME
        0100 T,                                          \ don't know what these numbers do...?
        0020 T,                                          \ TI-99 FIXED/80 file format code?

        70 TALLOT                                        \ move pointer to end of header

        FALSE DATA,                                      \ the "MORE-FIELD"= true (-1) if there are more files to load
        BEEF DATA,                                       \ place holder for the PROG-SIZE  (in bytes)
        ORG-ADDR@ DATA,                                  \ record the load address in the file
        DEAD @@ B,                                       \ 2 BYTES:  branch to address where the program starts
;

: FILE!  ( caddr -- )                                             \ c" MYFILE" FILE!
         dup len 0A > ABORT" File name too long. >10 chars"
\ move the string into the TI-99 header as UPPER CASE text
         LISTS @ swap UPPER$ COUNT >R  [TARGET] file-name  R> CMOVEL
         COLLAPSE ;

[cc] 12 $VARIABLE FILENAME$


: FILENAME:  BL WORD DUP file!                                     \ added to version 5 Jan2 2017
             FILENAME$ $! ;                                        \ make a copy of the string

: PROGRAM:            \ *new*  program: can declare the file name. DOES NOTHING IF NO NAME PROVIDED
          BL WORD DUP LEN 0>
          IF DUP FILE!  FILENAME$ $! THEN
         .EVEN
          CLR-JMPTABLE
          THERE BOOT-ADDRESS T! ;

: ?8K         ( n -- ) MAX-PROG > IF 9 ]asmerr THEN ;   \ check if too big

: IMAGE-SIZE ( -- n) THERE header@ - ;         \ calculate the file image size starting at header
: TCODE-SIZE ( -- n) THERE ORG-ADDR@ - ;       \ calculate the TI-99 code size.

: .XMEM   \ Display cross-assembler memory and dictionary usage report
        BASE @ >R
        DECIMAL
        CR
        CR ." TI-99 filename: "  FILENAME$ $.
        CR
        CR ." Fields         HEX  DECIMAL"
        CR ." -------------  ---  -------"
        CR ." Load address " ORG-ADDR@ .HEX/DEC
        CR ." Code size    " TCODE-SIZE DUP ?8K  .HEX/DEC
        CR ." Boot address " boot-address T@  .hex/dec
        CR ." Image size   " IMAGE-SIZE  .HEX/DEC
        CR ." Code words   " TCODEWORDS @ .hex/dec
        CR ." Forth words  " TFORTHWORDS @ .HEX/DEC

        R> BASE ! ;

: END.  \ finish off and create a report of what happened
         FILENAME$ LEN 0= ABORT" Missing FILENAME:"
         IMAGE-SIZE PROG-SIZE T!
         0  data,                               \ put a 0 after the last memory word of the program
         ?header                                \ check that the header is correct
         DECIMAL
         CR ." >>>> CROSS-ASSEMBLY COMPLETED <<<<<"
         .elapsed
         CR
         .XMEM
         CR
 ;

: SET-BOOT.  ( T'-addr -- ) BOOT-ADDRESS T!  ;

\ ===================================================================
\ E A 3  T A G G E D  O B J E C T   F I L E
\ O U T P U T   G E N E R A T O R

\ include cc9900\compiler\ea3gen.hsf

\ ===================================================================
\ S A V E  B I N A R Y  F I L E

\ TI-99 EDITOR ASSEMBLER BINARY FORMAT SAVE (Menu option 5 format)

: WRITE-IMG  ( segment $addr -- )
         >R DUP 4I@ 0 R> FIT? MKFILE >R   \ push the file handle to rstack
         DUP@ header@ ROT DROP            \ we write the file from the start of the header.
         IMAGE-SIZE R@ WRITEH DROP        \ write to the handle, drop the error flag
         R> CLOSEH ;                      \ close the file handle


: $SAVE-EA5. ( $filename -- )       \ save image as TI-99 EA5 file format
         cr ." Saved as file " DUP $. ." , "
         [TARGET-IMG SEGMENT] SWAP WRITE-IMG
         IMAGE-SIZE U. ." bytes" CR  ;


: WRITE-BIN  ( segment $addr -- )
       >R
       DUP 4I@ 0 R> FIT? MKFILE >R   \ push the file handle to rstack
       DUP@ org-addr @ ROT DROP      \ we write the file from origin
       TDP @ ORG-ADDR @ -            \ compute size of binary image
       R@ WRITEH DROP                \ write to the handle, drop the error flag
       R> CLOSEH ;                   \ close the file handle

: $SAVE.BIN ( $filename -- ) [TARGET-IMG SEGMENT] SWAP WRITE-BIN ;



include CC9900\COMPILER\INLIN99.HSF

HOST-COMPILING

: XASM ;                \ xassembler present label

CR .( === XASSEMBLER IS LOADED ===)
cr
