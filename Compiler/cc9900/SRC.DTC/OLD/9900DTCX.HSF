\
\ ==========================================================
\      TI-99  FORTH  DIRECT THREADED  PRIMITIVES

\              **** using branch & link ****


\ ==========================================================
\
\ This code, compiled with a cross compiler built on HSF2012
\ a re-build of HS/Forth for DOS by Brian Fox is for the TI-99 4/A Home Computer

\ Copyright (c) 2017 Brian Fox Ontario Canada
\ brian.fox@foxaudioresearch.ca
\ This program is free software; you can redistribute it and/or modify
\ it under the terms of the GNU General Public License as published by
\ the Free Software Foundation; either version 3 of the License, or
\ (at your option) any later version.
\ You should have received a copy of the GNU General Public License
\ along with this program.  If not, see <http://www.gnu.org/licenses/>.
\
\ This program is distributed in the hope that it will be useful,
\ but WITHOUT ANY WARRANTY; without even the implied warranty of
\ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
\ GNU General Public License for more details.

\ The work derived from CAMEL Forth under the GNU General Public License.
\ CamelForth (c) 2009 Bradford J. Rodriguez.
\ Commercial inquiries for Camel Forth should be directed to:
\ 115 First St., #105, Collingwood, Ontario L9Y 4W3 Canada
\ or via email to bj@camelforth.com
\ -----------------------------------------------------------

\ Overview:
\ *** uses BRANCH & LINK to call direct threaded words.
\ The advantage of this version is the by using BL instruction in each
\ Forth word, R11 contains the PFA of the word ie: where the Forth threaded
\ code begins !!!
\ This reduces the overhead of most words by about 10%. SEE: DOVAR

\ PERFORMANCE:
\ The direct threaded version on the 9900 runs empty loops 20% to 30% FASTER
\ than ITC Forth. However in a real world application of compiling the ASSEMBLER
\ where the compiler primitives (HERE ','  ALLOT) are code words, the speedup
\ is almost not measurable.

\ Multi-tasking ready:
\ CAMEL99 commandeers R13,R14 & R15 to allow the smallest multi-tasker
\ ever made. 3 instructions lets us jump to a task in about 20uS.
\ see: TASKS99.HSF

\ CREDITS:
\         Special thanks Mark Wills for giving the world TurboForth
\         It provided examples of how to deal with the crazy TI-99/4a

\         Also thanks go to Lee Stewart atariage.com who can spot
\         a bug a nautical mile away.

\         Big thanks to Dr. Brad Rodriguez for Camel Forth MSP430
\         The MSP430 provides other code examples that sometimes
\         translate nicely to the TMS9900

\ ==============================================================
\ C A M E L 9 9   R E G I S T E R   N A M E S   A N D  U S A G E

\ R0      general purpose register
\ R1      general purpose register
\ R2      general purpose register
\ R3      general purpose register
\ R4      TOP of stack cache
\ R5      overflow for '*' and '/',  general purpose register
\ R6      parameter stack pointer
\ R7      return stack pointer
\ R8      "w" register (working registers for Forth interpreter)
\ R9      Forth VM Instruction pointer
\ R10     Forth's "NEXT" routine cache
\ R11     Contains PFA when calling Forth word, OR sub-routine return register
\ R12     9900 CRU register  - OR - general purpose register
\ R13     Multi-tasker LINK to next task
\ R14     Multi-tasker Program counter: holds address of TSTAT routine see: TASKS99.HSF
\ R15     Multi-tasker task Status register

\  [UNDEFINED] XASSEMBLER
\  [IF]   include cc9900\asm99003.hsf
\  [ELSE] CR .( ** 9900 XASSEMBLER is loaded **)
\  [THEN]

\ ==============================================================
\ F O R T H   V I R T U A L   M A C H I N E  S U P P O R T

CROSS-COMPILING
[UNDEFINED] CALL,
[IF]

    CR ." Defining Forth Virtual machine MACROs ..."
    include cc9900\SRC.DTC\DTCVM.HSF  \ contains macros: PUSH POP CALL etc...

[THEN]

\ ==============================================================
\ T I - 9 9   S U P P O R T

    cr ." Including TI99 EQUATES"
    include cc9900\SRC.ITC\99equ.hsf


\ ==============================================================
\ XASM99 TI-99 CROSS-ASSEMBLER DIRECTIVES
cr ." Assembling Forth Primitives"

TARGET-COMPILING
              START.                \ sets a timer
              NEW.                  \ init target memory segment to FFFF
              A000 ORIGIN. \ we must set the origin before TI-99.EA5 directive
              TI-99.EA5             \ format the memory/file header for TI-99 EA5 file format

\ ==============================================================
\ Compiler extensions to manage copying certain primitives into hi-speed (HS) RAM

[CC] ORG-ADDR@ 2 CELLS +  equ HSprims         \ beginning of the code to be copied to HS ram
                 8388 equ HSstart       \ where we copy the code to in HS ram

: >HSRAM  ( label -- addr') HSprims -  HSstart + ;  \ converts assembler label to HS RAM address

\ ==============================================================
\ FAST CODE PRIMITIVES. Concept from TI-Forth and TURBO Forth, Mark Wills

\ The following code is copied into TI-99 "PAD" memory chip by INIT to address
\ _HSstart (8388). TI-99 "PAD" is the ONLY zero wait-state 16 bit buss wide
\ memory chip in the TI-99. But there is only 256 bytes! (shame) Having these
\ critical routines in fast memory makes more difference than ANY other
\ improvements

\ ==========================================================
\ DIRECT THREADED  NEXT pseudo-code:
\   (IP) -> W   fetch memory pointed by IP into "W" register
\   IP+2 -> IP  advance IP (assuming 2-byte addresses)
\   JP (W)      jump to the address in the W register
\               *TMS9900 does this in 2 instructions
\ ==========================================================
\

TARGET-COMPILING
l: _exit     *RP+ IP MOV,
l: _next*
@@9:         *IP+ W MOV,
                 *W B,

l: _?branch
              TOS DEC,
              TOS POP,
              @@2 JOC,
l: _branch   *IP IP ADD,
              @@9 JMP,
@@2:          IP INCT,
              @@9 JMP,

l: _docol     IP RPUSH,
              R11 IP MOV,
              @@9 JMP,

l: _lit       TOS     PUSH,
             *IP+ TOS MOV,
              @@9 JMP,

l: _@        *R4 R4 MOV,
              @@9 JMP,

l: _!        *SP+ *TOS MOV,

L: _DROP      TOS POP,
              @@9 JMP,

l: _DUP      TOS PUSH,
             @@9 JMP,

l: _PLUS    *SP+ TOS ADD,     \ ADD 2nd item to TOS and incr stack pointer.
             @@9 JMP,

l: _HSend   \ this label tells the compiler where the high speed code ends.

\ ==============================================================
\ calculate and name the entry points for the fast memory code

\ * Address NEXT2 must be loaded into R10 at startup *  ( see INIT in CAMEL99.HSF)
\ --------------------------------------------------
 _exit    >HSRAM equ HSEXIT
 _next*   >HSRAM equ HSNEXT  \ entry address of NEXT in fast RAM
 _docol   >HSRAM equ ENTR    \ code address of enter. This resolves 'DOCOL in CAMEL99.HSF
 _HSend   >HSRAM equ HSend   \ end of hi-speed memory code. Needed by copy loop in INIT
 _DUP   >HSRAM equ HSDUP
 _LIT   >HSRAM EQU HSLIT
 _@     >HSRAM EQU HS@
 _PLUS  >HSRAM EQU HSPLUS


[TC]
ENTR   RESOLVES 'DOCOL

\ ==============================================================
\   ********  C O M P I L E R   C O N T R O L ****************
HOST-COMPILING
    FALSE VALUE REGISTERS  \ TRUE -> use registers for do loop


\   **********************************************************
\ "EXECUTORS" are code routines that run specific word types

TARGET-COMPILING
\ Executor that executes a "CONSTANT"
l: _docon        TOS PUSH,   \ make room in TOS
            *R11 TOS MOV,    \ move PFA into Forth IP register    14
             NEXT,
_docon RESOLVES 'DOCON      \ 'DOCON is used by the cross-compiler

 \ Executor that executes a "VARIABLE"
l: _dovar         TOS PUSH,  \ make room in TOS                   28
             R11  TOS MOV,   \ move PFA into Forth IP register    14
             NEXT,

_dovar  RESOLVES 'DOVAR     \ 'DOVAR is used by the cross-compiler


\ In CAMEL99 the 9900 WP register doubles as User pointer
l: _douser   TOS PUSH,       \ Executor that executes a "USER VARIABLE"
                             \ (local to each task)
             TOS STWP,       \ store workspace register WP in TOS
            *R11 TOS ADD,    \ add contents of PFA to workspace address
             NEXT,
_douser  RESOLVES 'DOUSER  \ 'DOUSER is used by the cross-compiler



\ This took a while to figure out :-)
\ Example:
\     : CONS    CREATE , DOES> @ ;   This is the "defining word"
\    99 CONS X                       This is the "defined word"

\ Step by Step:
\ - When the defined word (X) is invoked is does a BL to the DOES> part of CONS
\ - The Forth IP has not moved.
\ - After X runs via BL instruction , R11 points to the address just past the
\   BL instruction and address. (X's PFA )
\ - We just push that onto the Forth stack (just like _dovar)
\ - We dect R11 to get the address that BL was branching to, (DOES> part
\   of CONS)
\ - We push the current IP
\ - We decrement R11 by 2 to point to the address of DOES> in CONS
\ - Make that address our new IP
\ - Advance the new IP past the branch instruction in DOES> which points
\   to "payload"
\   in DOES>  which is the execution token of '@'
\ - Now we run next which runs fetch (@) which takes the value of the address
\   on the TOS.

\   easy peasy :-)
l: _DODOES  ( -- a-addr)
            TOS PUSH,       \ save TOS reg on data stack
            R11 TOS MOV,    \ After BL R11 has defined word's PFA. Move to TOS
            IP  RPUSH,      \ save current IP on return stack
\ ** R11-2 points to defining word CODE B @@ _dodoes
           -2 (R11) IP MOV, \ move pointer to Forth IP
            IP  4 ADDI,     \ advance past branch to defining word's PFA
            NEXT,


\ ==============================================================
[CC] CR .( FORTH PRIMITIVES BEGIN) [TC]
TARGET-COMPILING

CODE EXIT
   *RP+ IP MOV,
   *IP+ W MOV,
         *W B,
ENDCODE   HSEXIT RESOLVES 'EXIT  \ compiler will compile HS version

CODE LIT
         TOS PUSH,
         *IP+ TOS MOV,
         NEXT,
ENDCODE  HSLIT  RESOLVES 'LIT

TARGET-COMPILING

\ CODE ?BRANCH
\             TOS DEC,
\             TOS POP,
\             @@2 JOC,
\ +CODE BRANCH
\             *IP IP ADD,
\             NEXT,
\ @@2:         IP INCT,
\             NEXT,
\     ENDCODE

\ CROSS-COMPILER
\ : ?BRANCH  _?branch >HSRAM T, ; IMMEDIATE
\ : BRANCH   _branch  >HSRAM T, ; IMMEDIATE



\ ==========================================================================
TARGET-COMPILING
CODE PERFORM ( 'xt -- )
           *TOS W MOV,
              TOS POP,
               *W B,
ENDCODE

CODE EXECUTE (  xt -- )
            TOS W MOV,
              TOS POP,
               *W B,
ENDCODE

[CC] CR .( MEMORY FETCH & STORE) [TC]
CODE !      ( n addr -- )
             *SP+ *TOS MOV,   \ 20
              TOS POP,        \ 22
              NEXT,           \ 42
              ENDCODE

CODE @      ( a -- w )
             *TOS TOS MOV,   \ 18
              next,
              ENDCODE

\ Aug 4 2018: fixed order of data to be ANS compliant
CODE 2!     ( d addr -- )
             *SP+ *TOS  MOV,    \ the top # of D is stored at the lower adrs
             *SP+ 2 (TOS) MOV,  \ next # stored 1 cell higher (addr+2)
              TOS POP,
              NEXT,
              ENDCODE

\ Aug 4 2018: fixed order of data to be ANS compliant
CODE 2@     ( addr -- d)  \ the lower address will appear on top of stack
              2 (TOS) PUSH,         \ 38
             *TOS TOS MOV,          \ 28
              NEXT,               \ = 66
              ENDCODE

CODE C!     ( c addr -- )
             *SP SWPB,               \ 14
             *SP *TOS MOVB,          \ 22   can't auto incr. It will only be by 1 with MOVB
              SP INCT,               \ 10   inc. stack pointer by 2
              TOS POP,               \ 22
              NEXT,                 \ =68
              ENDCODE

CODE COUNT  ( addr -- addr' u)
              TOS PUSH,
             *SP INC,
             *TOS TOS MOVB,
              TOS 8 SRL,
              NEXT,
              ENDCODE

CODE C@    ( addr -- c)
             *TOS TOS MOVB,
              TOS 8 SRL,
              NEXT,
              ENDCODE

CODE +!     ( n addr --)
             *SP+ *TOS ADD,          \ 14+8+4 = 26 cycles
              TOS POP,               \          22 cycles
              NEXT,                  \ -------------------
              ENDCODE               \          48 cycles

CODE C+!     ( c addr -- ) \ 8 bytes versus 12 bytes in Forth
             *SP SWPB,               \ 14
             *SP *TOS ADDB,          \ 22
              SP INCT,               \ 10
              TOS POP,               \ 22
              NEXT,                 \ =68
              ENDCODE

\ ==================================================================
[CC] CR .( RETURN STACK)  [TC]

CODE RP@     ( -- a )
              TOS PUSH,
              RP TOS MOV,
              NEXT,
              ENDCODE

CODE RP!     ( a -- )
              TOS RP MOV,
              TOS POP,
              NEXT,
              ENDCODE

CODE >R      ( w -- )
              RP DECT,          \ 10
              TOS *RP  MOV,     \ 18
             *SP+  TOS MOV,     \ 22
              NEXT,
              ENDCODE          \ 50

CODE DUP>R      ( w -- )
              RP DECT,          \ 10
              TOS *RP  MOV,     \ 18
              NEXT,
              ENDCODE          \ 50


CODE R>      ( -- w )
              SP DECT,          \ 10
              TOS *SP  MOV,     \ 18
             *RP+  TOS MOV,     \ 22
              NEXT,
              ENDCODE          \ 50

CODE R@      ( -- w )
              TOS PUSH,
             *RP TOS MOV,
              NEXT,
              ENDCODE

\ ==================================================================
[CC] CR .( DATA STACK) [TC]

CODE SP@     ( -- a )
              TOS PUSH,
              SP TOS MOV,
              NEXT,
              ENDCODE

CODE SP!     ( a -- )
              TOS SP MOV,
              TOS POP,
              NEXT,
              ENDCODE

CODE DROP    ( w -- )
              TOS POP,
              NEXT,
              ENDCODE

CODE NIP     ( n n' -- n')
              SP INCT,
              NEXT,
              ENDCODE   \ INLINE

CODE ?DUP    ( x -- 0 | x x)       \ ?DUP interleaved with DUP to save space
              TOS TOS MOV,          \ test for TOS<>0
              NE IF,              \ if TOS<>0 goto DUP
                  TOS PUSH,
              ENDIF,
              NEXT,
              ENDCODE

CODE DUP      TOS PUSH,   NEXT, ENDCODE

TARGET-COMPILING
CODE SWAP    ( w1 w2 -- w2 w1 )
              TOS   W MOV,          \ 14
             *SP  TOS MOV,          \ 18
              W   *SP MOV,          \ 18
              NEXT,                 \ 50
              ENDCODE

CODE OVER   ( w1 w2 -- w1 w2 w1 )
              TOS PUSH,             \ 28
              2 (SP) TOS MOV,       \ 22
              next,               \ 50
              ENDCODE

CODE ROT    ( n1 n2 n3 --  n2 n3 n1)
              2 (SP)    W MOV,      \ move bottom n1 to TEMP             14+8 =   22
             *SP   2 (SP) MOV,      \ move n2 to bottom position         14+4+8 = 26
              TOS     *SP MOV,      \ n3 moves to second                 14+4   = 18
              W       TOS MOV,      \ n1 goes to top of stack register   14+0   = 14
              NEXT,                 \                                             80
              ENDCODE

CODE -ROT    ( n1 n2 n3 --  n2 n3 n1)
              TOS       W MOV,
             *SP      TOS MOV,
              2 (SP)  *SP MOV,
              W    2 (SP) MOV,
              NEXT,
              ENDCODE

\ byte/word conversions
CODE ><      ( n -- n )            \ swap bytes in n
              TOS SWPB,            \ handy and only 1 instruction
              NEXT,
              ENDCODE  \ INLINE

\ used in number conversion. Same size as DROP DROP 3X faster
CODE 2DROP   ( n n -- )
              SP INCT,           \ 10
              TOS POP,           \ 28
              NEXT,            \ = 38
              ENDCODE

\ used 10x in the CAMEL Forth Kernel. Provides good speedup on some critical words
0 [IF]
 CODE 2DUP   ( n1 n2 -- n1 n2 n1 n2 )
             *SP W MOV,            \ 18 copy n1
              TOS PUSH,            \ 28 copy n2 onto stack
              W PUSH,              \ 28 push onto Stack
              NEXT,                \
             ENDCODE             \ 74,  5 instructions, 10 bytes
[ELSE]
\ faster version is 2 bytes bigger. It's hard to win with the 9900!
CODE 2DUP   ( n1 n2 -- n1 n2 n1 n2 )
              SP -4 ADDI,       \  14   make room for 2 cells
              4 (SP) *SP MOV,   \  26   n1->*SP
              TOS  2 (SP) MOV,  \  22   n2 -> next stack location
              NEXT,            \   62   3 instructions 12 bytes
              ENDCODE
[THEN]

CODE 2SWAP   ( n1 n2 n3 n4-- n3 n4 n1 n2)
              TOS       R0 MOV,    \ n4  14
             *SP        R1 MOV,    \ n3  14
              2 (SP)   TOS MOV,    \ n2  22
              4 (SP)   *SP MOV,    \ n1  26
              R0    2 (SP) MOV,    \     22
              R1    4 (SP) MOV,    \     22
              NEXT,                \    120
              ENDCODE

CODE PICK   ( n -- n)   \ GForth ITC takes 8 intel instructions for PICK
              TOS TOS ADD,   \ 14  (" n CELLS")
              SP TOS ADD,    \ 14
             *TOS TOS MOV,   \ 18
              NEXT,         \  46
              ENDCODE

0 [IF] \ From Wil Baden's TOOLBELT  Thanks Wil. RIP

CODE 3RD  ( a b c d --  a b c d b)    \ 2X faster than 3 PICK
              TOS PUSH,         \ 28
              4 (SP) TOS MOV,   \ 22
              NEXT,            \  50
              ENDCODE

 CODE 4TH
              TOS PUSH,
              6 (SP) TOS MOV,
              NEXT,
              ENDCODE
[THEN]

\ ==================================================================
[CC] CR .( LOGICAL OPERATIONS) [TC]

CODE AND     ( w w -- w )
             *SP INV,                  \ thanks to Mark Wills!   14
             *SP+ TOS SZC,             \ RFM for TMS9900 BF      20
              NEXT,                                           \ =34
              ENDCODE

CODE OR      ( w w -- w )
             *SP+ TOS OR,                                     \  22
              NEXT,
              ENDCODE    \ INLINE

CODE XOR     ( w w -- w )
             *SP+ TOS XOR,
              NEXT,
              ENDCODE   \ INLINE

\ ==================================================================
[CC] CR .( ARITHMETIC) [TC]
\ TOS in place math is about 40% faster with TOS in register
CODE 1+     ( n -- n')     \ changed from 1+ for compliance
              TOS INC,
              NEXT,
              ENDCODE      \ INLINE

CODE 1-      ( n -- n')
              TOS DEC,
              NEXT,
              ENDCODE     \ INLINE

CODE 2+     ( n -- n)   \ changed from 2+ for compliance
              TOS INCT,
              NEXT,
              ENDCODE      \ INLINE

CODE 2-     ( n -- n)
              TOS DECT,
              NEXT,
              ENDCODE   \ INLINE

CODE 2*      ( n -- n)     \ changed from 2* for compliance
              TOS TOS ADD,  \ mpy instruction is 52 clocks minimum. This is 14 clocks
              NEXT,
              ENDCODE   \ INLINE

CODE 4*      ( n -- nx4)    \ use in graphics & sprite calulations
              TOS 2 SLA,
              NEXT,
              ENDCODE   \ INLINE

CODE 8*      ( n -- nx8)   \ use in graphics & sprite calulations
              TOS 3 SLA,
              NEXT,
              ENDCODE   \ INLINE

CODE 2/      ( n -- n)     \ div instruction is 52 clocks minimum
              TOS 1 SRA,    \ this is 14
              NEXT,
              ENDCODE   \ INLINE

\ ==================================================================
[CC] CR  .( ANS Shift operations) [TC]

CODE RSHIFT  ( n bits -- n')  \ shift right logical. ANS/ISO Forth requirement
              TOS R0  MOV,            \ 14 the shift bits MUST be in R0 to do this
             *SP+ TOS   MOV,          \ 22
              R0 R0 MOV,              \ ANS:  1 0 LSHIFT -> 1
              NE IF,                  \       so skip the shift if R0=1
                 TOS R0 SRL,
              ENDIF,
              NEXT,
              ENDCODE

CODE LSHIFT  ( n bits -- n') \ shift left arithmetic. NOT ANS compliant
              TOS R0  MOV,           \ the shift bits MUST be in R0 to do this
             *SP+ TOS MOV,
              R0 R0 MOV,
              NE IF,
                 TOS R0  SLA,
              ENDIF,
              NEXT,
              ENDCODE

CODE SRA   ( n bits -- n') \ shift right arithmetic. Very handy for scaling
              TOS R0  MOV,            \ 14 the shift bits MUST be in R0 to do this
             *SP+ TOS   MOV,          \ 22
              TOS R0 SRA,
              NEXT,
              ENDCODE

CODE INVERT  ( u -- w)
              TOS INV,              \ 10
              NEXT,
              ENDCODE   \ INLINE

CODE +       ( u1 u2 -- u )
             *SP+ TOS ADD,         \ ADD 2nd item to TOS and incr stack pointer.
              NEXT,
              ENDCODE   \ INLINE

\ I found the 9900 weirdness but Brad's MSP430 code is 1 more instruction than mine :-)
CODE -       ( u1 u2 -- u )
             *SP+ TOS SUB,
              TOS NEG,         \ sign is wrong when subtracting a register from memory
              NEXT,
              ENDCODE

\ D+ is a better primitive for 9900 CPU
CODE D+   ( lo hi lo' hi' -- d)
             *SP+  R0  MOV,
             *SP+  TOS ADD,   \ add hi #s
              R0   *SP ADD,   \ add lo #s
              OC IF,            \ carry set?
                  TOS INC,      \ incr hi
              ENDIF,
              NEXT,
              ENDCODE

CODE ABS    ( n -- n )
              TOS ABS,
              NEXT,
              ENDCODE  \ INLINE

CODE NEGATE ( n -- n )
              TOS NEG,
              NEXT,
              ENDCODE  \ INLINE

CODE ALIGNED ( n -- n)
              TOS INC,
              TOS -2 ANDI,
              NEXT,
              ENDCODE

\ ==================================================================
[CC] CR  .( MULTIPLY AND DIVIDE) [TC]

CODE UM*     ( n n -- d)     \ 2 cells in -- 2 cells out
             *SP  TOS MPY,    \ 52+4=56
              R5  *SP MOV,    \ 18
              NEXT,           \ 74
              ENDCODE

CODE *      ( n n -- n)      \ same size as  : *  UM* DROP ; but faster
             *SP+ R3 MOV,     \ 22
              TOS R3 MPY,     \ 52  cool trick ! result goes to R4
              NEXT,           \ 74
              ENDCODE

CODE UM/MOD ( ud u1 -- u2 u3 ) \ numerator(32bits), divisor -- rem,quot
              TOS  R0 MOV,     \ divisor->R0                 14
             *SP+ TOS MOV,     \ POP high word into TOS      22
             *SP   R5 MOV,     \ MOVE low word to r5         18
              R0  TOS DIV,     \ perform unsigned division  124
              R5  *SP MOV,     \ push remainder              22
              NEXT,            \                            200
              ENDCODE

\ Signed divide using either Floored or Symmetric Integer Division.
\ Adapted with permission, from FBForth by Lee Stewart
\ This routine first does Symmetric Integer Division, then checks FLOOR
\ for whether we are doing Floored Integer Division.
\
\ Divides a 32 bit value in R1 and R2 by a 16 bit value in R0
\ Inputs:
\   TOS  denominator (divisor)
\   R1   MSB of numerator (dividend)
\   R2   LSB of numerator

\   TEMP   R3 sign of denominator
\   TEMP   W  sign of numerator
\   TEMP   R5 copy of numerator

\ VARIABLE
\   _floor =floored/symmetric division flag passed by caller
\     0 = symmetric division
\    -1 = floored division

\ Outputs:
\   TOS=16-bit quotient (quot)
\   R2=16-bit remainder (rem)
\   set flags to reflect signs of operands, and force operands positive...

VARIABLE FLOOR      \ variable controls symetrical(0) or floored(-1) division

CODE M/MOD  ( lsb msb n3 -- rem quot)
       TOS R3 MOV,             \ DUP for sign of denominator
       R1     POP,             \ POP the high word of ud to r1
       R1  W  MOV,             \ DUP for sign of numerator
       R1  R5 MOV,             \ DUP 2nd copy symmetric sign
      *SP  R2 MOV,             \ move low word of ud to r2 (keep stack pos.)

          TOS ABS,             \ force denominator positive
       R1  0 CMPI,             \ check sign of num
       LT IF,                  \ if numerator<0
           R1 INV,             \ DABS: invert numerator MSB and..
           R2 NEG,             \ ..negate numerator LSB
           OC IF,              \ if carry=TRUE
               R1 INC,         \ increment numerator MSB
           ENDIF,
       ENDIF,
       TOS R1 DIV,             \ perform the division. R1=quot, R2=rem

\ * Test for negative quotient
       R3 W  XOR,              \ compare signs of den and num
       LT IF,                  \ if different
           R1  NEG,            \ negate quotient
       ENDIF,
\ * check for remainder
       R2 0 CMPI,
       NE IF,                  \ if <>0
           R5  8000 ANDI,      \ test for negative numerator
           NE IF,              \ if signbit<>0
               R2 NEG,         \ rem. takes sign of num(symmetric)
           ENDIF,
\ * Handle floored division, if enabled
          FLOOR @@ R0 MOV,     \ symmetric or floored division?
           NE IF,              \ if <>0, do flooring
               W  8000 ANDI,   \ use XOR result to check num and den signs
               NE IF,
                   R1 DEC,     \ signs different, so floor quot
                   R3 R2 ADD,  \ rem = den + rem
               ENDIF,
           ENDIF,
       ENDIF,
       R1 TOS MOV,     \ quotient to tos
       R2 *SP MOV,     \ put remainder on open stack location
       NEXT,           \ we're outta here!
       ENDCODE         \ 72 bytes

\ ===================================================================
[CC] CR  .( COMPARISON) [TC]

CODE 0=     ( n -- ? )
              TOS TOS MOV,
              @@7 JMP,
+CODE =     ( n n -- ?)     \ Expanded for speed. Used 4X in Kernel
             *SP+ TOS CMP,
@@7:          TOS CLR,
              EQ IF,
@@9:                TOS SETO,
              ENDIF,
              NEXT,

\ stack setter routines are the smallest way to do this on 9900
@@8:          TOS CLR,   NEXT,
\ @@9:          TOS SETO,  NEXT, \ used = saves 2 bytes

\ using +CODE allows all these routines to jump inside CODE .. ENDCODE
+CODE 0<     ( n -- flag )
              TOS TOS  MOV,
              @@9 JLT,
              @@8 JMP,

+CODE U<    ( n1 n2 -- flag)
             *SP+ TOS CMP,
              @@9 JL,
              @@8 JHE,            \ changed to JHE due to bug on U>

+CODE >=     TOS DEC,             \ used in VDP driver
              @@1 JMP,
+CODE >     ( n1 n2 -- flag)
@@1:         *SP+ TOS CMP,
              @@9 JGT,
              @@8 JMP,

+CODE <     ( n1 n2 -- flag)
             *SP+ TOS CMP,
              @@9 JLT,
              @@8 JMP,
ENDCODE

\ ==================================================================
[CC] CR .( MIN & MAX ) [TC]
CODE MIN     ( n1 n2 -- n)
             *SP TOS CMP,    \ compare n1 & n2
              @@1 JLT,       \ if n1 < n2 goto @@1:
              SP INCT,       \ otherwise NIP n1
              NEXT,
+CODE MAX   ( n1 n2 -- n)
             *SP  TOS CMP,   \ compare n1 & n2
              @@2 JGT,       \ if n1 > n2 goto @@1:
              SP INCT,       \ otherwise DROP n1
              NEXT,
@@1: @@2:     TOS POP,       \ pop n1 into TOS
              NEXT,
ENDCODE   \ for MIN

\ In DTC we save space by using more code words
CODE UMIN     ( n1 n2 -- n)
             *SP TOS CMP,    \ compare n1 & n2
              @@1 JL,        \ if n1 < n2 goto @@1:
              SP INCT,       \ otherwise NIP n1
              NEXT,
+CODE UMAX   ( n1 n2 -- n)
             *SP  TOS CMP,   \ compare n1 & n2
              @@2 JH,       \ if n1 > n2 goto @@1:
              SP INCT,       \ otherwise DROP n1
              NEXT,
@@1: @@2:     TOS POP,       \ pop n1 into TOS
              NEXT,
ENDCODE   \ for MIN


\ ==================================================================
[CC] CR  .(  MOVE CMOVE CMOVE>  FILL ) [TC]

CODE CMOVE  ( src dst n -- )  \ forward character move
             *SP+ R0 MOV,       \ pop DEST into R0                         22
             *SP+ R1 MOV,       \ pop source into R1                       22
              TOS TOS MOV,
              NE IF,            \ if n<>0 do move
                 BEGIN,
                  *R1+ *R0+ MOVB, \ byte move, with auto increment by 1.   26
                   TOS DEC,       \ n is in TOS (R4)                       10
                 EQ UNTIL,
              ENDIF,                                                  \    10
              TOS POP,                                                \    22
              NEXT,                                                   \   112
              ENDCODE

CODE CMOVE>  ( src dst n -- )  \ move chars from end of string and go backwards
             *SP+ R0 MOV,       \ pop DEST into R0
             *SP+ R1 MOV,       \ pop source into R1
              TOS TOS MOV,
              NE IF,            \ if n<>0 do move
                 TOS R0 ADD,    \ point to end of src
                 TOS R1 ADD,    \ point to end of dest
                 BEGIN,
                   *R1 *R0 MOVB,
                    R1 DEC,     \ move the pointers back (NO auto decrement, damn)
                    R0 DEC,
                    TOS DEC,    \ decr the counter in TOS (R5)
                 EQ UNTIL,
              ENDIF,
              TOS POP,
              NEXT,
              ENDCODE

CODE FILL   ( addr cnt char -- )
             *SP+ R0 MOV,       \ pop cnt->R0                   22
             *SP+ R1 MOV,       \ pop addr->R1                  22
              TOS SWPB,         \                               10
              BEGIN,
                TOS *R1+ MOVB,  \ char is in TOS                20
                R0 DEC,         \ decr. count                   10
              EQ UNTIL,         \ loop until r0=0               10
              TOS POP,          \ refill the TOS register       22
              NEXT,             \                             =116
              ENDCODE

\ ===========================================================
[CC] CR  .( ANS Forth DO/LOOP ) [TC]

\  D O   L O O P S

\ Adapted from CAMEL Forth MSP430
\ ; '83 and ANSI standard loops terminate when the boundary of
\ ; limit-1 and limit is crossed, in either direction.  This can
\ ; be conveniently implemented by making the limit 8000h, so that
\ ; arithmetic overflow logic can detect crossing.  I learned this
\ ; trick from Laxen & Perry F83.

\ ===========================================================
\ conventional do loops use 2 cells on the RSTACK
[CC] CR  .( Rstack based DO/LOOP ) [TC]

CODE <?DO> ( limit ndx -- )
             *SP TOS CMP,       \ compare 2 #s
              @@1 JNE,          \ if they are not the same jump to regular 'do.' (BELOW)
              SP INCT,          \ remove limit
              TOS POP,          \ refill TOS
              EXIT2 @@ B,       \ otherwise do a forth 'exit'

+CODE <DO> ( limit indx -- )
@@1:          R0  8000 LI,      \ load "fudge factor" to LIMIT
             *SP+ R0  SUB,      \ Pop limit, compute 8000h-limit "fudge factor"
              R0  TOS ADD,      \ loop ctr = index+fudge
              R0  RPUSH,        \ rpush limit
              TOS RPUSH,        \ rpush index
              TOS POP,          \ refill TOS
              NEXT,
              ENDCODE

 CODE <LOOP>
              *RP INC,           \ increment loop
 @@2:          @@1 JNO,          \ if no overflow then loop again
               IP INCT,          \ move past (LOOP)'s in-line parameter
               @@3 JMP,          \ JUMP to unloop
 @@1:         *IP IP ADD,        \ jump back  (NO SPEED UP BY BRANCHING TO hi-speed version)
               next,           \ inline next is much faster
+CODE <+LOOP>
              TOS *RP ADD,      \ saving space by jumping into <loop>
              TOS POP,          \ refill TOS, (does not change overflow flag)
              @@2 JMP,
+CODE UNLOOP
@@3:         *RP+ *RP+ CMP,      \ INC by 4, collapse rstack frame
              NEXT,
              ENDCODE

CODE I       ( -- n)
              TOS PUSH,         \ making space in TOS slows this down  28
             *RP     TOS MOV,                                      \   18
              2 (RP) TOS SUB,   \ index = loopindex - fudge            22
              NEXT,                                                \   68
              ENDCODE

CODE J       ( -- n)
              TOS PUSH,
              4 (RP) TOS MOV,   \ outer loop index is on the rstack
              6 (RP) TOS SUB,   \ index = loopindex - fudge
              NEXT,
              ENDCODE
[THEN]

CODE BOUNDS ( adr len -- adr2 adr1)  \ same size as Forth version
             *SP R1 MOV,
              TOS *SP ADD,
              R1 TOS MOV,
              NEXT,
              ENDCODE

\ ===========================================================
[CC] CR  .(  BINARY ON OFF) [TC]

CODE ON      ( adr -- )
             *TOS SETO,          \ set all bits at adr to ones
              TOS POP,
              NEXT,
              ENDCODE

CODE OFF     ( adr -- )
             *TOS CLR,           \ 10+4 = 14
              TOS POP,           \       +22
              NEXT,              \ ----------
              ENDCODE           \        36

\ ===========================================================
[CC] CR  .( SKIP SCAN S= ) [TC]

\ used CAMEL Forth MSP430 as reference code

\ ; Although SKIP, SCAN, and S= are perhaps not the ideal factors
\ ; of WORD and FIND, they closely follow the string operations
\ ; available on many CPUs, and so are easy to implement and fast.

\ used CAMEL Forth MSP430 as reference code

CODE SKIP  ( c-addr u char -- c-addr' u')    \ skip matching chars
              TOS SWPB,                       \ fix this silly byte order. It took me hrs to realize this !@#$!
              2 (SP) W MOV,                   \ get address->w, leave space on stack
             *SP+ R1 MOV,                     \ POP count into R1, char is already in TOS
              NE IF,                          \ if r1=0 get out
                  BEGIN,
                    TOS *W+ CMPB,             \ does character match? &  auto-incr. address
                    @@2 JNE,                  \ NO MATCH jump out
                    R1 DEC,                   \ decr loop counter
                  EQ UNTIL,                   \ loop until R1=0
@@2:              W DEC,                      \ correct result address after auto-inc.
              ENDIF,
              W *SP  MOV,                     \ store updated address on stack
              R1 TOS MOV,                     \ updated count to TOS
              NEXT,
              ENDCODE

CODE SCAN   ( adr len char -- adr' len' )     \ find matching char
              TOS SWPB,                       \ silly machine needs this to compare memory to register
              2 (SP) R8 MOV,                   \ get address->w
             *SP+ R1 MOV,                     \ POP count into R1, char is already in TOS
              NE IF,                          \ R1<>0 ?
                    BEGIN,
                      *R8 TOS CMPB,             \ does character match?
                       @@2 JEQ,                  \ YES, we are done, JUMP OUT
                         W INC,                   \ next character
                        R1 DEC,                  \ dec. loop counter
                    EQ UNTIL,                   \ hit end of string, jmp out
              ENDIF,
@@2:          W *SP  MOV,                    \ store updated address on stack
              R1 TOS MOV,                     \ updated count to TOS
              NEXT,
              ENDCODE

\ ===========================================================
\ D I C T I O N A R Y   S E A R C H
\ We found the Camel Forth dictionary search to be a little slow on TI-99.
\ Creating (FIND) in assembler is smaller and about 5X faster than using
\ S= plus hi-level looping and address calculation

\ Usage:
\  FIND ( c-addr -- caddr  0) if not found
\                   xt     1) if immediate,
\                   xt    -1) if "normal"
\             LATEST @ (FIND) ;

\ By using counted strings for input we get the bonus of comparing
\ the length bytes AND exiting the string compare loop after 1 compare
\ if the lengths are not equal. This makes for a fast traversal of
\ the linked list.

\ We also chose to take advantage of the large TMS9900 register set.
\ Therefore the input arguments are held in 3 registers and are
\ transferred to 3 new registers for the string compare loop.
\ This guarantees the fastest reload for each new string compare.

\ Register Usage
\ Inputs:  R3 = traverses NFAs in the Forth dictionary
\          R8 = address of the counted string we are looking for
\          R5 = length of the counted string in R8 + 1 byte

\ string compare loop
\          R0 = number of characters to compare(search string length+1)
\          R1 = address of the 1st string to compare
\          R2 = address of the second string to compare

\ Outputs: R2 = address of found string -OR- address of search string on stack
\          R4 = Forth TOS register. Holds the true/false result flag


CODE (FIND) ( Caddr NFA -- XT ? )
          TOS R3 MOV,                 \ R3 = NFA which is a counted string
          TOS CLR,                    \ TOS is the output flag, init to zero
         *SP R8 MOV,                  \ R8 = caddr which is a counted string
          NE IF,                      \ if count<>0 do the search
            \ get the length byte of Caddr
             *R8 R5 MOVB,             \ caddr C@ -> R5
              R5 8 SRL,               \ get the byte on the correct side right
              R5 INC,                 \ skip length byte
              BEGIN,
               \ load char compare registers
                 R5 R0 MOV,           \ load R0 with length of caddr string
                 R8 R1 MOV,           \ load R1 with caddr string address
                 R3 R2 MOV,           \ load R2 with the NFA to compare
               \ inner character comparator loop
                 BEGIN,
                   *R1+ *R2+ CMPB,    \ compare char by char including the length byte
                    @@1 JNE,          \ ANY mismatch found, goto @@1
                    R0 DEC, EQ        \ decr. loop counter
                 UNTIL,               \ loop until R0=0
                 @@2 JMP,             \ WE FOUND IT!! exit the loop
               \ traverse link list to next NFA
@@1:             R3  -3 ADDI,         \ convert nfa>lfa
                *R3  R3 MOV, EQ       \ do a fetch, R3 now has new NFA
              UNTIL,
              NEXT,                   \ we got zero. End of the list! Go back to Forth

\ convert NFA in R3 to CFA -> R2
@@2:          R3 R2 MOV,              \ if found R3 has a name field address (NFA), copy to R2
             *R3 R0 MOVB,             \ get the length of the name to R0
              R0 SWPB,                \ fix the #$%!@$ byte order again
              R0 R2 ADD,              \ add length to R2, gets past the string to the CFA
              R2 INCT,                \ inc 1 for the count byte and 1 more for even address evaluation
              R2 -2 ANDI,             \ align R2 to even address boundary

\ test for immediate or normal word -> TOS
              TOS SETO,               \ we found a word so set TOS to true
              R3 DEC,                 \ R3 has the NFA. NFA-1 is the immediate field
             *R3 R0 MOVB,             \ read contents of the immediate field
              NE IF,
                   TOS NEG,           \ if non zero negate the TOS from -1 to 1
              ENDIF,                  \ and head for home
          ENDIF,
          R2 *SP MOV,                 \ replace Caddr with the found XT in R2
          NEXT,                       \ Return to Forth
          ENDCODE                    \ 42 BYTES

\ ===========================================================
[CC] CR  .( CAMEL99 custom primitives) [TC]

\ multi-tasking support
CODE PAUSE   ( -- )       \ MULTI-TASKER switcher needed by I/O words in Kernel
            NEXT,        \ patch CODE address with NEXT (replaced for multi-tasking)
            0000 T,
            ENDCODE

\ used in sprite control and very handy for byte/cell manipulation
 CODE SPLIT  ( AABB --  BB AA )  \ split cell into 2 bytes
              TOS W MOV,   \ make a copy
              TOS 8 SRL,   \ slide 'AA' to the right
              W FF ANDI,   \ mask out AA from the copy
              W PUSH,
              NEXT,
              ENDCODE

 CODE FUSE   ( BB  AA -- AABB )  \ FUSE 2 bytes into 1 cell
              TOS SWPB,
             *SP+  TOS ADD,
              NEXT,
              ENDCODE

[CC] CR  .( Code primitives complete) [TC]
