\
\ ==========================================================
\      TI-99  FORTH  DIRECT THREADED  PRIMITIVES
\ ==========================================================
\
\ This code, compiled with a cross compiler built on HSF2012
\ a re-build of HS/Forth for DOS by Brian Fox is for the TI-99 4/A Home Computer

\ Copyright (c) 2017 Brian Fox Ontario Canada
\ brian.fox@foxaudioresearch.ca
\ This program is free software; you can redistribute it and/or modify
\ it under the terms of the GNU General Public License as published by
\ the Free Software Foundation; either version 3 of the License, or
\ (at your option) any later version.
\ You should have received a copy of the GNU General Public License
\ along with this program.  If not, see <http://www.gnu.org/licenses/>.
\
\ This program is distributed in the hope that it will be useful,
\ but WITHOUT ANY WARRANTY; without even the implied warranty of
\ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
\ GNU General Public License for more details.

\ The work derived from CAMEL Forth under the GNU General Public License.
\ CamelForth (c) 2009 Bradford J. Rodriguez.
\ Commercial inquiries for Camel Forth should be directed to:
\ 115 First St., #105, Collingwood, Ontario L9Y 4W3 Canada
\ or via email to bj@camelforth.com
\ -----------------------------------------------------------

\ Overview:
\ This implementation creates a DIRECT-Threaded Code System with the
\ Top of stack (TOS) cached in Register 4 for a speed increase.
\ We have also tried to use less space where possible. Some primitives
\ are smaller in Assembly language but some are smaller in Forth.
\ We chose smaller is better except where performance would really suffer.

\ PERFORMANCE:
\ Cycle counting against Turbo Forth for TI-99, which does not keep TOS in
\ a register, shows as much as a 40% performance increase on simple primitives.
\ This is counter balanced by the slowdown of PUSHing and POPing the TOS
\ register which can slowdown other code words by as much as 100%.

\ The benchmark system, Turbo Forth, puts many small routines in the high
\ speed 16 bit RAM chip. To even come close to Turbo Forth we had to put
\ EXIT NEXT, ENTER, BRANCH and ?BRANCH and LIT in High Speed RAM.

\ CAMEL99 is roughly the same speed as TurboForth in "primtive" benchmarks
\ but is slower in number conversion/printing, conditionals and screen display.

\ ASM Macros are to code the Forth Virtual Machine in a slightly CPU
\ independant manner. They make sense to a Forth programmer but may
\ be less clear to someone new to Forth.
\ (see FORTHVM.HSF for detailS)

\ Multi-tasking ready:
\ CAMEL99 commandeers R13,R14 & R15 to allow the smallest multi-tasker
\ ever made. 3 instructions lets us jump to a task in about 20uS.
\ see: TASKS99.HSF

\ CREDITS:
\         Special thanks Mark Wills for giving the world TurboForth
\         It provided examples of how to deal with the crazy TI-99/4a

\         Also thanks go to to Lee Stewart atariage.com who can spot
\         a bug a nautical mile away.

\         Big thanks to Dr. Brad Rodriguez for Camel Forth MSP430
\         The MSP430 provides other code examples that sometimes
\         translate nicely to the TMS9900

\ ==============================================================
\ C A M E L 9 9   R E G I S T E R   N A M E S   A N D  U S A G E

\ R0      general purpose register
\ R1      general purpose register
\ R2      general purpose register
\ R3      general purpose register
\ R4      TOP of stack cache
\ R5      Temp for NEXT, overflow for '*' and '/',  general purpose register
\ R6      parameter stack pointer
\ R7      return stack pointer
\ R8      Forth 'W' register OR general purpose in a system CODE word
\ R9      Forth VM Instruction pointer
\ R10     Forth's "NEXT" routine cache
\ R11     9900 sub-routine return register  - OR - general purpose register
\ R12     9900 CRU register                 - OR - general purpose register
\ R13     Multi-tasker LINK to next task
\ R14     Multi-tasker Program counter: holds address of TSTAT routine see: TASKS99.HSF
\ R15     Multi-tasker task Status register

  [UNDEFINED] XASSEMBLER
  [IF]   include cc9900\asm99003.hsf
  [ELSE] CR .( ** 9900 XASSEMBLER is loaded **)
  [THEN]

\ ==============================================================
\ F O R T H   V I R T U A L   M A C H I N E  S U P P O R T

CROSS-COMPILING
[UNDEFINED] CALL,
[IF]

    CR ." Defining Forth Virtual machine MACROs ..."
    include cc9900\cclib\forthvm.hsf    \ contains macros: PUSH POP CALL etc...

[THEN]


\ ==============================================================
\ T I - 9 9   S U P P O R T

    cr ." Including TI99 EQUATES"
    include cc9900\99equ.hsf


\ ==============================================================
\ Compiler extensions to manage copying certain primitives into hi-speed (HS) RAM

loadaddress 2 cells + equ HSprims                   \ beginning of the code to be copied to HS ram
                 8388 equ HSstart                   \ where we copy the code to in HS ram

: >HSRAM  ( label -- addr') HSprims -  HSstart + ;  \ converts assembler label to HS RAM address
\ : CFA!    ( addr -- )   -2 TALLOT  DATA,  ;   **NOT FOR DTC***

\ ==============================================================
\ XASM99 TI-99 CROSS-ASSEMBLER DIRECTIVES
cr ." Assembling Forth Primitives"

CROSS-ASSEMBLING
              START.                \ sets a timer
              NEW.                  \ init target memory segment to FFFF
              ABSOLUTE A000 ORIGIN. \ we must set the origin before TI-99.EA5 directive
              TI-99.EA5             \ format the memory/file header for TI-99 EA5 file format

\ ==============================================================
\ FAST CODE PRIMITIVES. Concept from TI-Forth and TURBO Forth,
\ by Mark Wills

\ The following code is copied into TI-99 "PAD" memory chip by INIT to address _HSstart (8388)
\ TI-99 "PAD" is the ONLY zero wait-state 16 bit buss wide memory chip in the TI-99.
\ But there is only 256 bytes! (shame)
\ Having these critical routines in fast memory makes more difference than ANY other improvements

\ ==========================================================
\ DIRECT THREADED  NEXT pseudo-code:
\   (IP) -> W   fetch memory pointed by IP into "W" register
\   IP+2 -> IP  advance IP (assuming 2-byte addresses)
\   JP (W)      jump to the address in the W register
\ TMS9900 does this in 2 instructions
\ ==========================================================
\
l: _exit     *RP+ IP MOV,     \ placing EXIT before next saves space and is faster  22+next=60
l: _next                      \ Forth DTC NEXT routine
@@9:         *IP+  W MOV,     \ move IP to W & auto inc IP                   \ 22
             *W    B,         \ branch to the address in W                   \ 16
                                                                           \ = 38 vs 56 in ITC
l: _?branch   \ Faster way to avoid penalty of TOS refill
              TOS DEC,        \ After DEC if tos=0, this will cause a carry flag                        10
              TOS POP,        \ refill TOS changes L> A> EQ flags, BUT does not change carry flag       22
              @@2 JOC,        \                                                                         10
l: _branch   *IP IP ADD,      \ *IP points to an offset number in memory. Add it to IP causes a jump.
              @@9 JMP,
@@2:          IP INCT,        \ move IP forward past branch offset (don't branch)                       10
              @@9 JMP,        \ JMP to _next

l: _docol     IP RPUSH,       \                                                   28
              W 4 ADDI,       \ jump past the code fragment in the header         14
              W IP MOV,       \ move PFA into Forth IP register                   14
              @@9 JMP,        \                                                =  56 vs 42 ITC

 l: _lit      TOS PUSH,       \ 28
             *IP+ TOS MOV,    \ 22
              @@9 JMP,

l: _HSend                     \ this label tells the compiler where the high speed code ends.



\ ==============================================================
\ calculate and name the entry points for the fast memory code

\ * Address NEXT2 must be loaded into R10 at startup *  ( see INIT in CAMEL99.HSF)
\ --------------------------------------------------
 _exit    >HSRAM equ EXIT2
 _next    >HSRAM equ NEXT2   \ entry address of NEXT in fast RAM
 _docol   >HSRAM equ ENTR    \ code address of enter. This resolves 'DOCOL in CAMEL99.HSF
 _HSend   >HSRAM equ HSend   \ end of hi-speed memory code. Needed by copy loop in INIT
 _?branch >HSRAM equ ?BRANCH2
 _branch  >HSRAM equ BRANCH2
 _lit     >HSRAM equ LIT2
\  _douser  >HSRAM equ DOUSER2

\ ==============================================================
\   ********  C O M P I L E R   C O N T R O L ****************

    FALSE VALUE REGISTERS  \ TRUE -> use registers for do loop

\   **********************************************************

\ These are NOT Forth words, but code routines I call "EXECUTORS"

\ Executor that executes a "CONSTANT"
l: _docon    TOS PUSH,      \ make room in TOS
            *W+ *W+ CMP,     \  INC by 4
             *W TOS MOV,     \ move PFA into Forth IP register    14
              NEXT,

 \ Executor that executes a "VARIABLE"
l: _dovar     TOS    PUSH,   \ make room in TOS                   28
             *W+ *W+  CMP,   \ INC by 4
              W   TOS MOV,   \ move PFA into Forth IP register    14
              NEXT,

\ In CAMEL99 the 9900 WP register doubles as User pointer
l: _douser    TOS PUSH,      \ Executor that executes a "USER VARIABLE" (local to each task)
              TOS STWP,      \ store workspace register WP in TOS
             *W+ *W+ CMP,    \ INC by 4
             *W  TOS ADD,    \ add contents of PFA to workspace address
              NEXT,

\ ; push old IP onto the Return Stack
\ ; pop new IP from the CPU stack
\   note: the CPU stack is the Parameter Stack, and the
\          topmost element is now the PFA of the word...
\          exactly what we want!
\  NEXT    ; invoke high-level interpreter
l: _DODOES  ( -- a-addr)
              IP RPUSH,       \ 28
              TOS PUSH,       \ 28  push the CFA
              W   TOS MOV,    \ CFA is in TOS
             *TOS+ *TOS+ CMP, \ inc TOS by 4 converts CFA to PFA
              *W    IP  MOV,     \ pfa -> IP
              IP  4 ADDI, 
              NEXT,

\ =======================================================================
\ DTC MACROS are compiled into each FORTH word. NOT needed by CODE words.
\ reminder: We have to BRANCH to these routines because TMS9900
\ does not have a nestable sub-routine call.

CROSS-COMPILING
\ CR .( DTC macros )

: MAC.DOCOL      ENTR   @@ B, ;    ' MAC.DOCOL  IS JMP.DOCOL
: MAC.DOUSER    _douser @@ B, ;    ' MAC.DOUSER IS JMP.DOUSER
: MAC.DOCON     _docon  @@ B, ;    ' MAC.DOCON  IS JMP.DOCON
: MAC.DOVAR     _dovar  @@ B, ;    ' MAC.DOVAR  IS JMP.DOVAR

\ ==============================================================
CR .( FORTH PRIMITIVES BEGIN)

CROSS-ASSEMBLING
\ Forth hooks to hi-speed RAM routines
CODE: EXIT    ( -- )
              EXIT2 @@ B,     \ Branch to fast address
              END-CODE

CODE: ?BRANCH
             ?BRANCH2 @@ B,  \ Branch to fast address
              END-CODE

CODE: BRANCH
              BRANCH2 @@ B,   \ Branch to fast address
              END-CODE

CODE: LIT     LIT2 @@ B,      \ Branch to fast address
              END-CODE

\ ==========================================================================
CODE: EXECUTE ( xt -- )
              TOS W MOV,            \ move the execution token in TOS into temp
              TOS POP,              \ refill TOS
             *W   B,                \ branch to the address of the DOER routine
              END-CODE

CR .( MEMORY FETCH & STORE)
CODE: !      ( n addr -- )
             *SP+ *TOS MOV,   \ 20
              TOS POP,        \ 22
              NEXT,           \ 42
              END-CODE

CODE: @      ( a -- w )
             *TOS TOS MOV,   \ 18
              NEXT,
              END-CODE

\ Aug 4 2018: fixed order of data to be ANS compliant
CODE: 2!     ( d addr -- )
             *SP+ *TOS  MOV,    \ the top # of D is stored at the lower adrs
             *SP+ 2 (TOS) MOV,  \ next # stored 1 cell higher (addr+2)
              TOS POP,
              NEXT,
              END-CODE

\ Aug 4 2018: fixed order of data to be ANS compliant
CODE: 2@     ( addr -- d)  \ the lower address will appear on top of stack
              2 (TOS) PUSH,         \ 38
             *TOS TOS MOV,          \ 28
              NEXT,               \ = 66
              END-CODE

CODE: C!     ( c addr -- )
             *SP SWPB,               \ 14
             *SP *TOS MOVB,          \ 22   can't auto incr. It will only be by 1 with MOVB
              SP INCT,               \ 10   inc. stack pointer by 2
              TOS POP,               \ 22
              NEXT,                 \ =68
              END-CODE

CODE: COUNT  ( addr -- addr' u)
              TOS PUSH,              \ make a copy of addr
             *SP INC,                \ inc. past the count byte
l: _C@       *TOS TOS MOVB,          \ put C@ inline to save space   18
              TOS 8 SRL,                                       \     28
              NEXT,                                            \ C@= 46
              END-CODE

CODE: C@     _C@ @@ B,  END-CODE      \ give _C@ a dictionary header

CODE: +!     ( n addr --)
             *SP+ *TOS ADD,          \ 14+8+4 = 26 cycles
              TOS POP,               \          22 cycles
              NEXT,                  \ -------------------
              END-CODE               \          48 cycles

CODE: C+!     ( c addr -- ) \ 8 bytes versus 12 bytes in Forth
             *SP SWPB,               \ 14
             *SP *TOS ADDB,          \ 22
              SP INCT,               \ 10
              TOS POP,               \ 22
              NEXT,                 \ =68
              END-CODE

\ ==================================================================
CR .( RETURN STACK)

CODE: RP@     ( -- a )
              TOS PUSH,
              RP TOS MOV,
              NEXT,
              END-CODE

CODE: RP!     ( a -- )
              TOS RP MOV,
              TOS POP,
              NEXT,
              END-CODE

CODE: >R      ( w -- )
              RP DECT,          \ 10
              TOS *RP  MOV,     \ 18
             *SP+  TOS MOV,     \ 22
              NEXT,
              END-CODE          \ 50

CODE: DUP>R      ( w -- )
              RP DECT,          \ 10
              TOS *RP  MOV,     \ 18
              NEXT,
              END-CODE          \ 50


CODE: R>      ( -- w )
              SP DECT,          \ 10
              TOS *SP  MOV,     \ 18
             *RP+  TOS MOV,     \ 22
              NEXT,
              END-CODE          \ 50

CODE: R@      ( -- w )
              TOS PUSH,
             *RP TOS MOV,
              NEXT,
              END-CODE

\ ==================================================================
CR .( DATA STACK)

CODE: SP@     ( -- a )
              TOS PUSH,
              SP TOS MOV,
              NEXT,
              END-CODE

CODE: SP!     ( a -- )
              TOS SP MOV,
              TOS POP,
              NEXT,
              END-CODE

CODE: DROP    ( w -- )
              TOS POP,             \ 22 *SP+ TOS MOV,
              NEXT,
              END-CODE

CODE: NIP     ( n n' -- n')
              SP INCT,              \ 10
              NEXT,
              END-CODE

CODE: ?DUP    ( x -- 0 | x x)       \ ?DUP interleaved with DUP to save space
              TOS TOS MOV,          \ test for TOS<>0
              @@1 JNE,              \ if TOS<>0 goto DUP
              NEXT,                 \ goto next word
+CODE: DUP    ( w -- w w )          \ create a Forth Header for DUP
@@1:          TOS PUSH,
              NEXT,
              END-CODE


CODE: SWAP    ( w1 w2 -- w2 w1 )
              TOS   W MOV,          \ 14
             *SP  TOS MOV,          \ 18
              W   *SP MOV,          \ 18
              NEXT,                 \ 50
              END-CODE

CODE: OVER   ( w1 w2 -- w1 w2 w1 )
              TOS PUSH,             \ 28
              2 (SP) TOS MOV,       \ 22
              NEXT,                 \ 50
              END-CODE

CODE: ROT    ( n1 n2 n3 --  n2 n3 n1)
              2 (SP)    W MOV,      \ move bottom n1 to TEMP             14+8 =   22
             *SP   2 (SP) MOV,      \ move n2 to bottom position         14+4+8 = 26
              TOS     *SP MOV,      \ n3 moves to second                 14+4   = 18
              W       TOS MOV,      \ n1 goes to top of stack register   14+0   = 14
              NEXT,                 \                                             80
              END-CODE

CODE: -ROT    ( n1 n2 n3 --  n2 n3 n1)
              TOS       W MOV,
             *SP      TOS MOV,
              2 (SP)  *SP MOV,
              W    2 (SP) MOV,
              NEXT,
              END-CODE

\ byte/word conversions
CODE: ><      ( n -- n )           \ swap bytes in n
              TOS SWPB,            \ handy and only 1 instruction
              NEXT,
              END-CODE

\ used in number conversion. Same size as DROP DROP 3X faster
CODE: 2DROP   ( n n -- )
              SP INCT,           \ 10
              TOS POP,           \ 28
              NEXT,            \ = 38
              END-CODE

\ used 10x in the CAMEL Forth Kernel. Provides good speedup on some critical words
 CODE: 2DUP   ( n1 n2 -- n1 n2 n1 n2 )
             *SP W MOV,            \ 18 copy n1
              TOS PUSH,            \ 28 copy n2 onto stack
              W PUSH,              \ 28 push onto Stack
              NEXT,                \
             END-CODE             \ 74,  5 instructions, 10 bytes

\ faster version is 2 bytes bigger. It's hard to win with the 9900!
\ CODE: 2DUP   ( n1 n2 -- n1 n2 n1 n2 )
\              SP -4 ADDI,       \  14   make room for 2 cells
\              4 (SP) *SP MOV,   \  26   n1->*SP
\              TOS  2 (SP) MOV,  \  22   n2 -> next stack location
\              NEXT,            \   62   ,  3 instructions 12 bytes
\              END-CODE

CODE: 2SWAP   ( n1 n2 n3 n4-- n3 n4 n1 n2)
              TOS       R0 MOV,    \ n4  14
             *SP        R1 MOV,    \ n3  14
              2 (SP)   TOS MOV,    \ n2  22
              4 (SP)   *SP MOV,    \ n1  26
              R0    2 (SP) MOV,    \     22
              R1    4 (SP) MOV,    \     22
              NEXT,                \    120
              END-CODE

CODE: PICK   ( n -- n)   \ GForth ITC takes 10 intel instructions for PICK
              TOS TOS ADD,   \ 14  (" n CELLS")
              SP TOS ADD,    \ 14
             *TOS TOS MOV,   \ 18
              NEXT,         \  46
              END-CODE

0 [IF] \ From Wil Baden's TOOLBELT  Thanks Wil. RIP

CODE: 3RD  ( a b c d --  a b c d b)    \ 2X faster than 3 PICK
              TOS PUSH,         \ 28
              4 (SP) TOS MOV,   \ 22
              NEXT,            \  50
              END-CODE

 CODE: 4TH
              TOS PUSH,
              6 (SP) TOS MOV,
              NEXT,
              END-CODE
[THEN]

\ ==================================================================
CR .( LOGICAL OPERATIONS)

CODE: AND     ( w w -- w )
             *SP INV,                  \ thanks to Mark Wills!   14
             *SP+ TOS SZC,             \ RFM for TMS9900 BF      20
              NEXT,                                           \ =34
              END-CODE

CODE: OR      ( w w -- w )
             *SP+ TOS OR,                                     \  22
              NEXT,
              END-CODE

CODE: XOR     ( w w -- w )
             *SP+ TOS XOR,
              NEXT,
              END-CODE

\ ==================================================================
CR .( ARITHMETIC)
\ TOS in place math is about 40% faster with TOS in register
CODE: 1+     ( n -- n')     \ changed from 1+ for compliance
              TOS INC,
              NEXT,
              END-CODE

CODE: 1-      ( n -- n')
              TOS DEC,
              NEXT,
              END-CODE

CODE: 2+     ( n -- n)   \ changed from 2+ for compliance
              TOS INCT,
              NEXT,
              END-CODE

CODE: 2-     ( n -- n)
              TOS DECT,
              NEXT,
              END-CODE

CODE: 2*      ( n -- n)     \ changed from 2* for compliance
              TOS TOS ADD,  \ mpy instruction is 52 clocks minimum. This is 14 clocks
              NEXT,
              END-CODE

CODE: 4*      ( n -- nx4)    \ use in graphics & sprite calulations
              TOS 2 SLA,
              NEXT,
              END-CODE

CODE: 8*      ( n -- nx8)   \ use in graphics & sprite calulations
              TOS 3 SLA,
              NEXT,
              END-CODE

CODE: 2/      ( n -- n)     \ div instruction is 52 clocks minimum
              TOS 1 SRA,    \ this is 14
              NEXT,
              END-CODE

\ ==================================================================
CR .( ANS Shift operations)

CODE: RSHIFT  ( n bits -- n')  \ shift right logical. ANS/ISO Forth requirement
              TOS R0  MOV,            \ 14 the shift bits MUST be in R0 to do this
             *SP+ TOS   MOV,          \ 22
              R0 R0 MOV,              \ ANS:  1 0 LSHIFT -> 1
              NE IF,                  \       so skip the shift if R0=1
                 TOS R0 SRL,
              ENDIF,
              NEXT,
              END-CODE

CODE: LSHIFT  ( n bits -- n') \ shift left arithmetic. NOT ANS compliant
              TOS R0  MOV,           \ the shift bits MUST be in R0 to do this
             *SP+ TOS MOV,
              R0 R0 MOV,
              NE IF,
                 TOS R0  SLA,
              ENDIF,
              NEXT,
              END-CODE

CODE: SRA   ( n bits -- n') \ shift right arithmetic. Very handy for scaling
              TOS R0  MOV,            \ 14 the shift bits MUST be in R0 to do this
             *SP+ TOS   MOV,          \ 22
              TOS R0 SRA,
              NEXT,
              END-CODE

CODE: INVERT  ( u -- w)
              TOS INV,              \ 10
              NEXT,
              END-CODE

\ : +   ( u1 u2 -- u ) UM+ DROP ;  original Camel Forth code is bigger
CODE: +       ( u1 u2 -- u )
             *SP+ TOS ADD,         \ ADD 2nd item to TOS and incr stack pointer.
              NEXT,
              END-CODE

\ I found the 9900 weirdness but Brad's MSP430 code is 1 more instruction than mine :-)
CODE: -       ( u1 u2 -- u )
             *SP+ TOS SUB,
              TOS NEG,         \ sign is wrong when subtracting a register from memory
              NEXT,
              END-CODE

CODE: M+      ( d n -- d )     \ add single to double signed output
              TOS  2 (SP) ADD,
              OC IF,
                 *SP INC,
              ENDIF,
              TOS POP,
              NEXT,
              END-CODE

CODE: ABS    ( n -- n )
              TOS ABS,
              NEXT,
              END-CODE

CODE: NEGATE ( n -- n )
              TOS NEG,
              NEXT,
              END-CODE

CODE: ALIGNED ( n -- n)
              TOS INC,
              TOS -2 ANDI,
              NEXT,
              END-CODE

\ ==================================================================
CR .( MULTIPLY AND DIVIDE)

CODE: UM*     ( n n -- d)     \ 2 cells in -- 2 cells out
             *SP  TOS MPY,    \ 52+4=56
              R5  *SP MOV,    \ 18
              NEXT,           \ 74
              END-CODE

CODE: *      ( n n -- n)      \ same size as  : *  UM* DROP ; but faster
             *SP+ R3 MOV,     \ 22
              TOS R3 MPY,     \ 52  cool trick ! result goes to R4
              NEXT,           \ 74
              END-CODE

CODE: UM/MOD ( ud u1 -- u2 u3 ) \ numerator(32bits), divisor -- rem,quot
              TOS  R0 MOV,     \ divisor->R0                 14
             *SP+ TOS MOV,     \ POP high word into TOS      22
             *SP   R5 MOV,     \ MOVE low word to r5         18
              R0  TOS DIV,     \ perform unsigned division  124
              R5  *SP MOV,     \ push remainder              22
              NEXT,            \                            200
              END-CODE

\ Signed divide using either Floored or Symmetric Integer Division.
\ Adapted with permission, from FBForth by Lee Stewart
\ This routine first does Symmetric Integer Division, then checks FLOOR
\ for whether we are doing Floored Integer Division.
\
\ Divides a 32 bit value in R1 and R2 by a 16 bit value in R0
\ Inputs:
\   TOS  denominator (divisor)
\   R1   MSB of numerator (dividend)
\   R2   LSB of numerator

\   TEMP   R3 sign of denominator
\   TEMP   W  sign of numerator
\   TEMP   R5 copy of numerator

\ VARIABLE
\   _floor =floored/symmetric division flag passed by caller
\     0 = symmetric division
\    -1 = floored division

\ Outputs:
\   TOS=16-bit quotient (quot)
\   R2=16-bit remainder (rem)
\   set flags to reflect signs of operands, and force operands positive...

l: _floor  DATA -1    \ variable controls symetrical(0) or floored(-1) division

CODE: M/MOD  ( lsb msb n3 -- rem quot)
       TOS R3 MOV,             \ DUP for sign of denominator
       R1     POP,             \ POP the high word of ud to r1
       R1  W  MOV,             \ DUP for sign of numerator
       R1  R5 MOV,             \ DUP 2nd copy symmetric sign
      *SP  R2 MOV,             \ move low word of ud to r2 (keep stack pos.)

          TOS ABS,             \ force denominator positive
       R1  0 CMPI,             \ check sign of num
       LT IF,                  \ if numerator<0
           R1 INV,             \ DABS: invert numerator MSB and..
           R2 NEG,             \ ..negate numerator LSB
           OC IF,              \ if carry=TRUE
               R1 INC,         \ increment numerator MSB
           ENDIF,
       ENDIF,
       TOS R1 DIV,             \ perform the division. R1=quot, R2=rem

\ * Test for negative quotient
       R3 W  XOR,              \ compare signs of den and num
       LT IF,                  \ if different
           R1  NEG,            \ negate quotient
       ENDIF,
\ * check for remainder
       R2 0 CMPI,
       NE IF,                  \ if <>0
           R5  8000 ANDI,      \ test for negative numerator
           NE IF,              \ if signbit<>0
               R2 NEG,         \ rem. takes sign of num(symmetric)
           ENDIF,
\ * Handle floored division, if enabled
          _floor @@ R0 MOV,    \ symmetric or floored division?
           NE IF,              \ if <>0, do flooring
               W  8000 ANDI,   \ use XOR result to check num and den signs
               NE IF,
                   R1 DEC,     \ signs different, so floor quot
                   R3 R2 ADD,  \ rem = den + rem
               ENDIF,
           ENDIF,
       ENDIF,
       R1 TOS MOV,     \ quotient to tos
       R2 *SP MOV,     \ put remainder on open stack location
       NEXT,           \ we're outta here!
       END-CODE        \ 72 bytes

\ ==================================================================
\ array operation nice in theory, but not that important
0 [IF]
CODE: *+     ( addr ndx size -- addr')  \ array address calculator
             *SP+ TOS MPY,              \ 60
             *SP+ TOS MOV,              \ 22
              R5  TOS ADD,              \ 14
              NEXT,                    \ =96
              END-CODE
[THEN]

\ ==================================================================
cr .( COMPARISON)

CODE: 0=     ( n -- ?)
              TOS TOS MOV,
              @@9 JEQ,
@@8:          TOS CLR,
              NEXT,
@@9:          TOS SETO,
              NEXT,

\ using +CODE allows all these routines to jump inside CODE: .. END-CODE
+CODE: =      ( n n -- ? )
             *SP+ TOS CMP,
              @@9 JEQ,
              @@8 JMP,

+CODE: 0<     ( n -- flag )
              TOS TOS  MOV,
              @@9 JLT,
              @@8 JMP,

+CODE: U<    ( n1 n2 -- flag)
             *SP+ TOS CMP,
              @@9 JL,
              @@8 JHE,             \ changed to JHE due to bug on U>

+CODE: >     ( n1 n2 -- flag)
             *SP+ TOS CMP,
              @@9 JGT,
              @@8 JMP,

+CODE: <     ( n1 n2 -- flag)
             *SP+ TOS CMP,
              @@9 JLT,
              @@8 JMP,

0 [IF]   \ saves 14 bytes if Forth versions are used

+CODE: U>    ( n1 n2 -- flag)
             *SP+ TOS CMP,
              @@9 JH,
              @@8 JLE,             \ *BUG* had to use JLE not JL
+CODE: 0>     ( n -- flag )
              TOS TOS MOV,
              @@9 JGT,
              @@8 JMP,
+CODE: <>    ( n n -- ? )
             *SP+ TOS CMP,
              @@9 JNE,
              @@8 JMP,
[THEN]
              END-CODE

\ ==================================================================
CR .( MIN & MAX )
CODE: MIN     ( n1 n2 -- n)
             *SP TOS CMP,    \ compare n1 & n2
              @@1 JLT,       \ if n1 < n2 goto @@1:
              SP INCT,       \ otherwise NIP n1
              NEXT,
+CODE: MAX   ( n1 n2 -- n)
             *SP  TOS CMP,   \ compare n1 & n2
              @@2 JGT,       \ if n1 > n2 goto @@1:
              SP INCT,       \ otherwise DROP n1
              NEXT,
@@1: @@2:     TOS POP,       \ pop n1 into TOS
              NEXT,
END-CODE   \ for MIN

\ ==================================================================
CR .(  MOVE CMOVE CMOVE>  FILL )

CODE: CMOVE  ( src dst n -- )  \ forward character move
             *SP+ R0 MOV,       \ pop DEST into R0                         22
             *SP+ R1 MOV,       \ pop source into R1                       22
              TOS TOS MOV,
              NE IF,            \ if n<>0 do move
                 BEGIN,
                  *R1+ *R0+ MOVB, \ byte move, with auto increment by 1.   26
                   TOS DEC,       \ n is in TOS (R4)                       10
                 EQ UNTIL,
              ENDIF,                                                  \    10
              TOS POP,                                                \    22
              NEXT,                                                   \   112
              END-CODE

CODE: CMOVE>  ( src dst n -- )  \ move chars from end of string and go backwards
             *SP+ R0 MOV,       \ pop DEST into R0
             *SP+ R1 MOV,       \ pop source into R1
              TOS TOS MOV,
              NE IF,            \ if n<>0 do move
                 TOS R0 ADD,    \ point to end of src
                 TOS R1 ADD,    \ point to end of dest
                 BEGIN,
                   *R1 *R0 MOVB,
                    R1 DEC,     \ move the pointers back (NO auto decrement, damn)
                    R0 DEC,
                    TOS DEC,    \ decr the counter in TOS (R5)
                 EQ UNTIL,
              ENDIF,
              TOS POP,
              NEXT,
              END-CODE

CODE: FILL   ( addr cnt char -- )
             *SP+ R0 MOV,       \ pop cnt->R0                   22
             *SP+ R1 MOV,       \ pop addr->R1                  22
              TOS SWPB,         \                               10
              BEGIN,
                TOS *R1+ MOVB,  \ char is in TOS                20
                R0 DEC,         \ decr. count                   10
              EQ UNTIL,         \ loop until r0=0               10
              TOS POP,          \ refill the TOS register       22
              NEXT,             \                             =116
              END-CODE

\ ===========================================================
cr .( ANS Forth DO/LOOP )

\  D O   L O O P S

\ Adapted from CAMEL Forth MSP430
\ ; '83 and ANSI standard loops terminate when the boundary of
\ ; limit-1 and limit is crossed, in either direction.  This can
\ ; be conveniently implemented by making the limit 8000h, so that
\ ; arithmetic overflow logic can detect crossing.  I learned this
\ ; trick from Laxen & Perry F83.

\ ===========================================================
REGISTERS [IF]
\ CAMEL Forth prefers to put loop index and limit in registers.
\ Using 2 registers makes DO LOOPs about 14% faster
\ BUT it is NOT COMPATIBLE with the workspace based multi-tasker

  INCLUDE CC9900\CCLIB\DOFAST.HSF
CR .( *** NOT MULTI-TASKER COMPATIBLE!! ***)

[ELSE]

\ ===========================================================
\ conventional do loops use 2 cells on the RSTACK
cr .( Rstack based DO/LOOP )

CODE: <?DO> ( limit ndx -- )
             *SP TOS CMP,       \ compare 2 #s
              @@1 JNE,          \ if they are not the same jump to regular 'do.' (BELOW)
              SP INCT,          \ remove limit
              TOS POP,          \ refill TOS
              EXIT2 @@ B,       \ otherwise do a forth 'exit'

+CODE: <DO> ( limit indx -- )
@@1:          R0  8000 LI,      \ load "fudge factor" to LIMIT
             *SP+ R0  SUB,      \ Pop limit, compute 8000h-limit "fudge factor"
              R0  TOS ADD,      \ loop ctr = index+fudge
              R0  RPUSH,        \ rpush limit
              TOS RPUSH,        \ rpush index
              TOS POP,          \ refill TOS
              NEXT,
              END-CODE

 CODE: <LOOP>
              *RP INC,           \ increment loop
 @@2:          @@1 JNO,          \ if no overflow then loop again
               IP INCT,          \ move past (LOOP)'s in-line parameter
               @@3 JMP,          \ JUMP to unloop
 @@1:         *IP IP ADD,        \ jump back  (NO SPEED UP BY BRANCHING TO hi-speed version)
               NEXT,            \ branch *R10
+CODE: <+LOOP>
              TOS *RP ADD,      \ saving space by jumping into <loop>
              TOS POP,          \ refill TOS, (does not change overflow flag)
              @@2 JMP,
+CODE: UNLOOP
@@3:         *RP+ *RP+ CMP,      \ INC by 4, 2 bytes, collapse rstack frame
              NEXT,
              END-CODE

CODE: I       ( -- n)
              TOS PUSH,         \ making space in TOS slows this down  28
             *RP     TOS MOV,                                      \   18
              2 (RP) TOS SUB,   \ index = loopindex - fudge            22
              NEXT,                                                \   68
              END-CODE

CODE: J       ( -- n)
              TOS PUSH,
              4 (RP) TOS MOV,   \ outer loop index is on the rstack
              6 (RP) TOS SUB,   \ index = loopindex - fudge
              NEXT,
              END-CODE
[THEN]

CODE: BOUNDS ( adr len -- adr2 adr1)  \ same size as Forth version
             *SP R1 MOV,
              TOS *SP ADD,
              R1 TOS MOV,
              NEXT,
              END-CODE

\ ===========================================================
CR .(  BINARY ON OFF)

CODE: ON      ( adr -- )
             *TOS SETO,          \ set all bits at adr to ones
              TOS POP,
              NEXT,
              END-CODE

CODE: OFF     ( adr -- )
             *TOS CLR,           \ 10+4 = 14
              TOS POP,           \       +22
              NEXT,              \ ----------
              END-CODE           \        36

\ ===========================================================
cr .( SKIP SCAN S= )

\ used CAMEL Forth MSP430 as reference code

\ ; Although SKIP, SCAN, and S= are perhaps not the ideal factors
\ ; of WORD and FIND, they closely follow the string operations
\ ; available on many CPUs, and so are easy to implement and fast.

\ used CAMEL Forth MSP430 as reference code

CODE: SKIP  ( c-addr u char -- c-addr' u')    \ skip matching chars
              TOS SWPB,                       \ fix this silly byte order. It took me hrs to realize this !@#$!
              2 (SP) W MOV,                   \ get address->w, leave space on stack
             *SP+ R1 MOV,                     \ POP count into R1, char is already in TOS
              NE IF,                          \ if r1=0 get out
                BEGIN,
                  TOS *W+ CMPB,               \ does character match? &  auto-incr. address
                  @@2 JNE,                    \ no, so we are done
                  R1 DEC,                     \ decr loop counter
                EQ UNTIL,                     \ try again
@@2:            W DEC,                        \ correct result address after auto-inc.
              ENDIF,
              W *SP  MOV,                     \ store updated address on stack
              R1 TOS MOV,                     \ updated count to TOS
              NEXT,
              END-CODE

CODE: SCAN   ( adr len char -- adr' len' )    \ find matching char
              TOS SWPB,                       \ silly machine needs this to compare memory to register
              2 (SP) W MOV,                   \ get address->w
             *SP+ R1 MOV,                     \ POP count into R1, char is already in TOS
              NE IF,                          \ R1<>0 ?
                 BEGIN,
                   TOS *W+ CMPB,               \ does character match?
                   @@2 JEQ,                   \ YES, we are done, JUMP OUT
                   R1 DEC,                    \ dec. loop counter
                 EQ UNTIL,
@@2:             W DEC,
              ENDIF,
              W *SP  MOV,                     \ store updated address on stack
              R1 TOS MOV,                     \ updated count to TOS
              NEXT,
              END-CODE
\ ===========================================================
\ adapted from Camel Forth MSP430.
\ TMS9900 does not have a SUBC instruction. I could not figure out how to do
\ the clever SUB with carry trick that Brad used on MSP430 so Old fashioned
\ jumps had to suffice.

CODE: S=  ( C-addr1 C-addr2 cnt1+1 -- n )      \ compare counted strings (1st byte is the length)
\      s1<s2 : n=-1:, s1=s2: n=0,  s1>s2 : n=1 \ slightly different than MSP430 version
              R2 POP,                          \ adrs2 -> R2
              R1 POP,                          \ adrs1 -> R1
              TOS R0 MOV,                      \ cnt -> R0
              NE IF,                           \ if count<>0 do search
                 TOS CLR,                      \ TOS=0 means we have a match
                 BEGIN,
                   *R1+ *R2+ CMPB,             \ compare char by char with 2 register auto incrementing
                    @@2 JNE,                   \ mismatch found, goto @@2
                    R0 DEC,                    \ decr. loop counter
                 EQ UNTIL,                     \ loop while R0 > 0
                 NEXT,                         \ match! Return to Forth.

@@2:          LT IF,   TOS INC,                \ R1<R2 set to 1
                 ELSE, TOS DEC,                \ R1>R2 set to -1
                 ENDIF,
              ENDIF,
              NEXT,                            \ Return to Forth
              END-CODE                         \ 30 BYTES

\ ===========================================================
\ D I C T I O N A R Y   S E A R C H
\ We found the Camel Forth dictionary search to be a little slow on TI-99.
\ Creating (FIND) in assembler is smaller and about 5X faster than using
\ S= plus hi-level looping and address calculation

\ Usage:
\  FIND ( c-addr -- caddr  0) if not found
\                   xt     1) if immediate,
\                   xt    -1) if "normal"
\             LATEST @ (FIND) ;

\ By using counted strings for input we get the bonus of comparing
\ the length bytes AND exiting the string compare loop after 1 compare
\ if the lengths are not equal. This makes for a fast traversal of
\ the linked list.

\ We also chose to take advantage of the large TMS9900 register set.
\ Therefore the input arguments are held in 3 registers and are
\ transferred to 3 new registers for the string compare loop.
\ This guarantees the fastest reload for each new string compare.

\ Register Usage
\ Inputs:  R3 = traverses NFAs in the Forth dictionary
\          R8 = address of the counted string we are looking for
\          R5 = length of the counted string in R8 + 1 byte

\ string compare loop
\          R0 = number of characters to compare(search string length+1)
\          R1 = address of the 1st string to compare
\          R2 = address of the second string to compare

\ Outputs: R2 = address of found string -OR- address of search string on stack
\          R4 = Forth TOS register. Holds the true/false result flag


CODE: (FIND) ( Caddr NFA -- XT ? )
          TOS R3 MOV,                 \ R3 = NFA which is a counted string
          TOS CLR,                    \ TOS is the output flag, init to zero
         *SP R8 MOV,                  \ R8 = caddr which is a counted string
          NE IF,                      \ if count<>0 do the search
            \ get the length byte of Caddr
             *R8 R5 MOVB,             \ caddr C@ -> R5
              R5 8 SRL,               \ get the byte on the correct side right
              R5 INC,                 \ skip length byte
              BEGIN,
               \ load char compare registers
                 R5 R0 MOV,           \ load R0 with length of caddr string
                 R8 R1 MOV,           \ load R1 with caddr string address
                 R3 R2 MOV,           \ load R2 with the NFA to compare
               \ inner character comparator loop
                 BEGIN,
                   *R1+ *R2+ CMPB,    \ compare char by char including the length byte
                    @@1 JNE,          \ ANY mismatch found, goto @@1
                    R0 DEC, EQ        \ decr. loop counter
                 UNTIL,               \ loop until R0=0
                 @@2 JMP,             \ WE FOUND IT!! exit the loop
               \ traverse link list to next NFA
@@1:             R3  -3 ADDI,         \ convert nfa>lfa
                *R3  R3 MOV, EQ       \ do a fetch, R3 now has new NFA
              UNTIL,
              NEXT,                   \ we got zero. End of the list! Go back to Forth

\ convert NFA in R3 to CFA -> R2
@@2:          R3 R2 MOV,              \ if found R3 has a name field address (NFA), copy to R2
             *R3 R0 MOVB,             \ get the length of the name to R0
              R0 SWPB,                \ fix the #$%!@$ byte order again
              R0 R2 ADD,              \ add length to R2, gets past the string to the CFA
              R2 INCT,                \ inc 1 for the count byte and 1 more for even address evaluation
              R2 -2 ANDI,             \ align R2 to even address boundary

\ test for immediate or normal word -> TOS
              TOS SETO,               \ we found a word so set TOS to true
              R3 DEC,                 \ R3 has the NFA. NFA-1 is the immediate field
             *R3 R0 MOVB,             \ read contents of the immediate field
              NE IF,
                   TOS NEG,           \ if non zero negate the TOS from -1 to 1
              ENDIF,                  \ and head for home
          ENDIF,
          R2 *SP MOV,                 \ replace Caddr with the found XT in R2
          NEXT,                       \ Return to Forth
          END-CODE                    \ 42 BYTES

\ ===========================================================
cr .( CAMEL99 custom primitives)

\ multi-tasking support
CODE: PAUSE   ( -- )             \ MULTI-TASKER switcher needed by I/O words in Kernel
            _NEXT @@ B,          \ patch CODE address with NEXT (replaced for multi-tasking)
            END-CODE

\ used in sprite control and very handy for byte/cell manipulation
 CODE: SPLIT  ( AABB --  BB AA )  \ split cell into 2 bytes
              TOS W MOV,   \ make a copy
              TOS 8 SRL,   \ slide 'AA' to the right
              W FF ANDI,   \ mask out AA from the copy
              W PUSH,
              NEXT,
              END-CODE

 CODE: FUSE   ( BB  AA -- AABB )  \ FUSE 2 bytes into 1 cell
              TOS SWPB,
             *SP+  TOS ADD,
              NEXT,
              END-CODE

cr .( Code primitives complete)
